<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Heap Allocator Visualization - CS107 Stanford</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" href="../stylesheet.css">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    /* Clean, professional styling */
    body {
      background: #f8f9fa;
      min-height: 100vh;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    
    .main-card {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      padding: 30px;
      margin: 20px 0;
    }
    
    .header {
      text-align: center;
      margin-bottom: 30px;
      padding-bottom: 20px;
      border-bottom: 2px solid #4CAF50;
    }
    
    .header h1 {
      color: #333;
      font-size: 32px;
      margin: 10px 0;
      font-weight: 700;
    }
    
    .header p {
      color: #666;
      font-size: 16px;
      margin: 10px 0;
    }
    
    .badge {
      display: inline-block;
      background: #4CAF50;
      color: white;
      padding: 5px 15px;
      border-radius: 4px;
      font-size: 14px;
      font-weight: bold;
      margin: 0 5px;
    }
    
    /* Control Panel */
    .control-panel {
      background: #f5f5f5;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 25px;
      border: 1px solid #ddd;
    }
    
    .control-row {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-bottom: 15px;
      align-items: center;
    }
    
    .control-group {
      display: flex;
      align-items: center;
      gap: 10px;
      background: white;
      padding: 10px 15px;
      border-radius: 4px;
      border: 1px solid #e0e0e0;
    }
    
    .control-group label {
      font-weight: 600;
      color: #555;
      font-size: 14px;
    }
    
    button {
      padding: 8px 16px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-family: 'EB Garamond', Georgia, serif;
      font-size: 15px;
      font-weight: 600;
      transition: background-color 0.2s ease;
    }
    
    button:hover:not(:disabled) {
      background: #45a049;
    }
    
    button:disabled {
      background: #cccccc;
      cursor: not-allowed;
    }
    
    button.danger {
      background: #f44336;
    }
    
    button.danger:hover:not(:disabled) {
      background: #da190b;
    }
    
    button.success {
      background: #4CAF50;
    }
    
    button.warning {
      background: #ff9800;
    }
    
    select, input {
      padding: 8px 12px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-family: 'EB Garamond', Georgia, serif;
      font-size: 14px;
      background: white;
      transition: border-color 0.3s;
    }
    
    select:focus, input:focus {
      outline: none;
      border-color: #4CAF50;
    }
    
    /* Beautiful Tabs */
    .tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 25px;
      border-bottom: 3px solid #e0e0e0;
      padding-bottom: 0;
    }
    
    .tab {
      padding: 12px 25px;
      cursor: pointer;
      background: #f5f5f5;
      border: none;
      border-radius: 10px 10px 0 0;
      font-weight: 600;
      color: #666;
      transition: all 0.3s ease;
      position: relative;
      top: 3px;
    }
    
    .tab:hover {
      background: #e8e8e8;
    }
    
    .tab.active {
      background: #4CAF50;
      color: white;
    }
    
    .tab-content {
      display: none;
      animation: fadeIn 0.5s;
    }
    
    .tab-content.active {
      display: block;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    /* Heap Visualization */
    .heap-container {
      background: #ffffff;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 20px;
      margin: 20px 0;
      min-height: 400px;
      position: relative;
    }
    
    .heap-title {
      position: absolute;
      top: -15px;
      left: 30px;
      background: white;
      padding: 5px 15px;
      border-radius: 20px;
      font-weight: bold;
      color: #4CAF50;
      border: 2px solid #4CAF50;
    }
    
    .heap-blocks {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 20px;
    }
    
    .heap-block {
      border: 3px solid;
      border-radius: 10px;
      padding: 10px;
      position: relative;
      transition: opacity 0.2s ease;
      min-width: 100px;
      background: white;
    }
    
    .heap-block:hover {
      opacity: 0.9;
    }
    
    .heap-block.free {
      background: #e8f5e9;
      border-color: #4CAF50;
    }
    
    .heap-block.allocated {
      background: #ffebee;
      border-color: #f44336;
    }
    
    .heap-block.coalescing {
      background: #fff8e1;
      border-color: #ffc107;
      animation: coalesce 1s ease;
    }
    
    .heap-block.splitting {
      background: #e3f2fd;
      border-color: #2196f3;
      animation: split 1s ease;
    }
    
    @keyframes coalesce {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    
    @keyframes split {
      0% { transform: scaleX(1); }
      50% { transform: scaleX(1.2); }
      100% { transform: scaleX(1); }
    }
    
    .block-header {
      font-size: 11px;
      color: #666;
      padding: 5px;
      background: rgba(255, 255, 255, 0.7);
      border-radius: 5px;
      margin-bottom: 8px;
      font-family: 'Courier New', monospace;
      text-align: center;
    }
    
    .block-size {
      font-weight: bold;
      font-size: 18px;
      text-align: center;
      margin: 10px 0;
      color: #333;
    }
    
    .block-address {
      font-size: 10px;
      color: #888;
      text-align: center;
      font-family: 'Courier New', monospace;
    }
    
    .block-footer {
      font-size: 11px;
      color: #666;
      padding: 5px;
      background: rgba(255, 255, 255, 0.7);
      border-radius: 5px;
      margin-top: 8px;
      font-family: 'Courier New', monospace;
      text-align: center;
    }
    
    .block-payload {
      background: rgba(255, 255, 255, 0.9);
      padding: 8px;
      margin: 8px 0;
      border-radius: 5px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      text-align: center;
      min-height: 30px;
      border: 1px dashed #999;
    }
    
    /* Free List Visualization */
    .freelist-container {
      background: #f5f5f5;
      border-radius: 8px;
      padding: 20px;
      margin: 20px 0;
      border: 1px solid #ddd;
    }
    
    .freelist-title {
      font-weight: bold;
      color: #1976d2;
      margin-bottom: 15px;
      font-size: 18px;
      text-align: center;
    }
    
    .freelist-chain {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      gap: 10px;
    }
    
    .freelist-node {
      background: #e8f5e9;
      border: 2px solid #4caf50;
      padding: 15px;
      border-radius: 4px;
      min-width: 80px;
      text-align: center;
      font-weight: bold;
      transition: opacity 0.2s;
    }
    
    .freelist-node:hover {
      opacity: 0.9;
    }
    
    .freelist-arrow {
      font-size: 24px;
      color: #4caf50;
      font-weight: bold;
    }
    
    /* Statistics Panel */
    .stats-panel {
      background: #f5f5f5;
      border-radius: 8px;
      padding: 20px;
      margin: 20px 0;
      border: 1px solid #ddd;
    }
    
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
    }
    
    .stat-card {
      background: white;
      padding: 15px;
      border-radius: 4px;
      text-align: center;
      border: 1px solid #e0e0e0;
    }
    
    .stat-label {
      font-size: 12px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 5px;
    }
    
    .stat-value {
      font-size: 24px;
      font-weight: bold;
      color: #667eea;
    }
    
    .stat-unit {
      font-size: 14px;
      color: #999;
    }
    
    /* Legend */
    .legend {
      display: flex;
      justify-content: center;
      gap: 30px;
      margin: 20px 0;
      padding: 15px;
      background: #f5f5f5;
      border-radius: 10px;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .legend-box {
      width: 30px;
      height: 30px;
      border: 3px solid;
      border-radius: 5px;
    }
    
    .legend-box.free {
      background: linear-gradient(135deg, #e8f8f5, #a8e6cf);
      border-color: #51cf66;
    }
    
    .legend-box.allocated {
      background: linear-gradient(135deg, #ffe5e5, #ffb3ba);
      border-color: #ff6b6b;
    }
    
    .info-box {
      background: linear-gradient(135deg, #e3f2fd, #bbdefb);
      border-left: 5px solid #2196f3;
      padding: 15px 20px;
      margin: 20px 0;
      border-radius: 0 10px 10px 0;
    }
    
    .info-box h3 {
      color: #1976d2;
      margin-top: 0;
    }
    
    .back-link {
      text-align: center;
      margin: 20px 0;
    }
    
    .back-link a {
      color: white;
      text-decoration: none;
      font-weight: bold;
      padding: 10px 20px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 25px;
      transition: all 0.3s;
    }
    
    .back-link a:hover {
      background: rgba(255, 255, 255, 0.3);
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="back-link">
      <a href="../projects.html">‚Üê Back to Projects</a>
    </div>
    
    <div class="main-card">
      <div class="header">
        <h1>üßÆ Heap Allocator Visualization</h1>
        <p>Interactive demonstration of heap memory allocation strategies from CS107 Stanford</p>
        <div>
          <span class="badge">CS107</span>
          <span class="badge">Systems Programming</span>
          <span class="badge">Memory Management</span>
        </div>
      </div>
      
      <!-- Control Panel -->
      <div class="control-panel">
        <div class="control-row">
          <div class="control-group">
            <label>Implementation:</label>
            <select id="allocator-type">
              <option value="implicit">Implicit Free List</option>
              <option value="explicit">Explicit Free List (with Footer)</option>
            </select>
          </div>
          
          <div class="control-group">
            <label>Heap Size:</label>
            <select id="heap-size">
              <option value="256">256 bytes</option>
              <option value="512" selected>512 bytes</option>
              <option value="1024">1024 bytes</option>
            </select>
          </div>
          
          <div class="control-group">
            <label>Allocation Size:</label>
            <input type="number" id="alloc-size" value="32" min="8" max="256" step="8">
            <span style="font-size: 12px; color: #666;">bytes</span>
          </div>
        </div>
        
        <div class="control-row">
          <button onclick="allocateMemory()" class="success">
            üéØ Malloc
          </button>
          <button onclick="freeMemory()" class="danger">
            üóëÔ∏è Free
          </button>
          <button onclick="randomOperation()" class="warning">
            üé≤ Random Op
          </button>
          <button onclick="resetHeap()">
            üîÑ Reset Heap
          </button>
          <button onclick="runScenario()">
            ‚ñ∂Ô∏è Run Scenario
          </button>
        </div>
      </div>
      
      <!-- Tabs -->
      <div class="tabs">
        <div class="tab active" onclick="switchTab('heap')">
          Heap View
        </div>
        <div class="tab" onclick="switchTab('freelist')">
          Free List Structure
        </div>
        <div class="tab" onclick="switchTab('stats')">
          Statistics
        </div>
        <div class="tab" onclick="switchTab('learn')">
          Learn
        </div>
      </div>
      
      <!-- Tab Contents -->
      <div id="heap-tab" class="tab-content active">
        <div class="heap-container">
          <div class="heap-title">Heap Memory Layout</div>
          <div id="heap-visualization" class="heap-blocks"></div>
        </div>
        
        <div class="legend">
          <div class="legend-item">
            <div class="legend-box free"></div>
            <span><strong>Free Block</strong></span>
          </div>
          <div class="legend-item">
            <div class="legend-box allocated"></div>
            <span><strong>Allocated Block</strong></span>
          </div>
        </div>
      </div>
      
      <div id="freelist-tab" class="tab-content">
        <div class="freelist-container">
          <div class="freelist-title">Free List Chain (Explicit Implementation)</div>
          <div id="freelist-visualization" class="freelist-chain"></div>
        </div>
        
        <div class="info-box">
          <h3>‚ÑπÔ∏è About Free Lists</h3>
          <p><strong>Implicit Free List:</strong> Free blocks are found by linear scan through all blocks.</p>
          <p><strong>Explicit Free List:</strong> Free blocks are linked together using next/prev pointers stored in the payload area, enabling O(1) coalescing with footers.</p>
        </div>
      </div>
      
      <div id="stats-tab" class="tab-content">
        <div class="stats-panel">
          <div class="stats-grid">
            <div class="stat-card">
              <div class="stat-label">Total Heap Size</div>
              <div class="stat-value" id="stat-total">512</div>
              <div class="stat-unit">bytes</div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Allocated</div>
              <div class="stat-value" id="stat-allocated">0</div>
              <div class="stat-unit">bytes</div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Free</div>
              <div class="stat-value" id="stat-free">512</div>
              <div class="stat-unit">bytes</div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Fragmentation</div>
              <div class="stat-value" id="stat-fragmentation">0</div>
              <div class="stat-unit">%</div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Free Blocks</div>
              <div class="stat-value" id="stat-freeblocks">1</div>
              <div class="stat-unit">blocks</div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Allocations</div>
              <div class="stat-value" id="stat-allocations">0</div>
              <div class="stat-unit">total</div>
            </div>
          </div>
        </div>
        
        <div class="info-box" style="margin-top: 20px;">
          <h3>üìä Performance Metrics</h3>
          <p><strong>Fragmentation:</strong> Percentage of free memory that cannot be used due to being split into small, non-contiguous blocks.</p>
          <p><strong>Coalescing:</strong> Merging adjacent free blocks to reduce fragmentation.</p>
        </div>
      </div>
      
      <div id="learn-tab" class="tab-content">
        <div class="info-box">
          <h3>üìö Key Concepts</h3>
          <ul>
            <li><strong>8-byte Alignment:</strong> All blocks are aligned to 8-byte boundaries for performance.</li>
            <li><strong>Headers:</strong> Each block has a header containing size and allocation status.</li>
            <li><strong>Footers (Explicit):</strong> Enable constant-time coalescing by finding the previous block.</li>
            <li><strong>Splitting:</strong> Large free blocks are split to satisfy smaller requests.</li>
            <li><strong>Coalescing:</strong> Adjacent free blocks are merged to reduce fragmentation.</li>
            <li><strong>First-fit:</strong> Allocator searches from the beginning and uses the first suitable block.</li>
          </ul>
        </div>
        
        <div class="info-box">
          <h3>üéØ CS107 Implementation Details</h3>
          <p>This visualization demonstrates the concepts from CS107 Assignment 6:</p>
          <ul>
            <li>Implicit free list with linear search (O(n) allocation)</li>
            <li>Explicit free list with next/prev pointers (O(1) coalescing)</li>
            <li>Footer optimization for bidirectional traversal</li>
            <li>Minimum block size enforcement</li>
            <li>Proper alignment and size masking</li>
          </ul>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    // Heap Allocator Implementation
    class HeapAllocator {
      constructor(size, type = 'implicit') {
        this.type = type;
        this.heapSize = size;
        this.blocks = [];
        this.allocations = 0;
        this.init();
      }
      
      init() {
        // Initialize with one large free block
        this.blocks = [{
          address: 0,
          size: this.heapSize,
          allocated: false,
          id: 'block-0',
          next: null,
          prev: null
        }];
      }
      
      malloc(requestSize) {
        // Align to 8 bytes
        const alignedSize = Math.ceil(requestSize / 8) * 8;
        const totalSize = alignedSize + 8; // Include header size
        
        // Find first fit
        for (let i = 0; i < this.blocks.length; i++) {
          const block = this.blocks[i];
          if (!block.allocated && block.size >= totalSize) {
            // Split if remaining space is large enough
            if (block.size > totalSize + 16) {
              // Create new free block
              const newBlock = {
                address: block.address + totalSize,
                size: block.size - totalSize,
                allocated: false,
                id: `block-${Date.now()}`,
                next: block.next,
                prev: block.id
              };
              
              // Update current block
              block.size = totalSize;
              block.allocated = true;
              block.next = this.type === 'explicit' ? newBlock.id : null;
              
              // Insert new block
              this.blocks.splice(i + 1, 0, newBlock);
              
              // Animation
              this.animateSplit(block.id);
            } else {
              // Use entire block
              block.allocated = true;
            }
            
            this.allocations++;
            this.updateVisualization();
            return block.id;
          }
        }
        
        alert('Out of memory! No suitable block found.');
        return null;
      }
      
      free(blockId) {
        const index = this.blocks.findIndex(b => b.id === blockId);
        if (index === -1 || !this.blocks[index].allocated) {
          alert('Invalid free operation!');
          return;
        }
        
        this.blocks[index].allocated = false;
        
        // Coalesce with adjacent free blocks
        this.coalesce(index);
        this.updateVisualization();
      }
      
      coalesce(index) {
        const block = this.blocks[index];
        let coalesced = false;
        
        // Check next block
        if (index < this.blocks.length - 1 && !this.blocks[index + 1].allocated) {
          const nextBlock = this.blocks[index + 1];
          block.size += nextBlock.size;
          block.next = nextBlock.next;
          this.blocks.splice(index + 1, 1);
          coalesced = true;
        }
        
        // Check previous block
        if (index > 0 && !this.blocks[index - 1].allocated) {
          const prevBlock = this.blocks[index - 1];
          prevBlock.size += block.size;
          prevBlock.next = block.next;
          this.blocks.splice(index, 1);
          coalesced = true;
        }
        
        if (coalesced) {
          this.animateCoalesce();
        }
      }
      
      animateSplit(blockId) {
        const element = document.querySelector(`[data-block-id="${blockId}"]`);
        if (element) {
          element.classList.add('splitting');
          setTimeout(() => element.classList.remove('splitting'), 1000);
        }
      }
      
      animateCoalesce() {
        const blocks = document.querySelectorAll('.heap-block.free');
        blocks.forEach(block => {
          block.classList.add('coalescing');
          setTimeout(() => block.classList.remove('coalescing'), 1000);
        });
      }
      
      updateVisualization() {
        this.renderHeap();
        this.renderFreeList();
        this.updateStats();
      }
      
      renderHeap() {
        const container = document.getElementById('heap-visualization');
        container.innerHTML = '';
        
        this.blocks.forEach(block => {
          const div = document.createElement('div');
          div.className = `heap-block ${block.allocated ? 'allocated' : 'free'}`;
          div.setAttribute('data-block-id', block.id);
          div.style.width = `${Math.max(100, block.size * 0.8)}px`;
          
          div.innerHTML = `
            <div class="block-header">Header (8 bytes)</div>
            <div class="block-address">0x${block.address.toString(16).padStart(4, '0')}</div>
            <div class="block-size">${block.size} bytes</div>
            <div class="block-payload">${block.allocated ? 'User Data' : 'FREE'}</div>
            ${this.type === 'explicit' && !block.allocated ? 
              '<div class="block-footer">Footer (8 bytes)</div>' : ''}
          `;
          
          div.onclick = () => {
            if (block.allocated) {
              if (confirm(`Free this block (${block.size} bytes)?`)) {
                this.free(block.id);
              }
            }
          };
          
          container.appendChild(div);
        });
      }
      
      renderFreeList() {
        const container = document.getElementById('freelist-visualization');
        container.innerHTML = '';
        
        if (this.type === 'implicit') {
          container.innerHTML = '<p style="text-align:center; color:#666;">Implicit free list: No explicit chain (linear scan required)</p>';
          return;
        }
        
        // Show explicit free list chain
        const freeBlocks = this.blocks.filter(b => !b.allocated);
        freeBlocks.forEach((block, index) => {
          const node = document.createElement('div');
          node.className = 'freelist-node';
          node.innerHTML = `
            <div>${block.size}B</div>
            <div style="font-size:10px;">0x${block.address.toString(16)}</div>
          `;
          container.appendChild(node);
          
          if (index < freeBlocks.length - 1) {
            const arrow = document.createElement('span');
            arrow.className = 'freelist-arrow';
            arrow.innerHTML = '‚Üí';
            container.appendChild(arrow);
          }
        });
        
        if (freeBlocks.length === 0) {
          container.innerHTML = '<p style="text-align:center; color:#666;">No free blocks in the list</p>';
        }
      }
      
      updateStats() {
        const totalSize = this.heapSize;
        const allocatedSize = this.blocks.filter(b => b.allocated).reduce((sum, b) => sum + b.size, 0);
        const freeSize = totalSize - allocatedSize;
        const freeBlocks = this.blocks.filter(b => !b.allocated);
        
        // Calculate fragmentation
        const largestFree = Math.max(...freeBlocks.map(b => b.size), 0);
        const fragmentation = freeSize > 0 ? Math.round((1 - largestFree / freeSize) * 100) : 0;
        
        document.getElementById('stat-total').textContent = totalSize;
        document.getElementById('stat-allocated').textContent = allocatedSize;
        document.getElementById('stat-free').textContent = freeSize;
        document.getElementById('stat-fragmentation').textContent = fragmentation;
        document.getElementById('stat-freeblocks').textContent = freeBlocks.length;
        document.getElementById('stat-allocations').textContent = this.allocations;
      }
    }
    
    // Global allocator instance
    let allocator = new HeapAllocator(512, 'implicit');
    
    // Control functions
    function allocateMemory() {
      const size = parseInt(document.getElementById('alloc-size').value);
      allocator.malloc(size);
    }
    
    function freeMemory() {
      const allocated = allocator.blocks.filter(b => b.allocated);
      if (allocated.length === 0) {
        alert('No blocks to free!');
        return;
      }
      
      // Free a random allocated block
      const randomBlock = allocated[Math.floor(Math.random() * allocated.length)];
      allocator.free(randomBlock.id);
    }
    
    function randomOperation() {
      if (Math.random() < 0.6) {
        const sizes = [16, 24, 32, 48, 64, 96, 128];
        const size = sizes[Math.floor(Math.random() * sizes.length)];
        document.getElementById('alloc-size').value = size;
        allocateMemory();
      } else {
        freeMemory();
      }
    }
    
    function resetHeap() {
      const size = parseInt(document.getElementById('heap-size').value);
      const type = document.getElementById('allocator-type').value;
      allocator = new HeapAllocator(size, type);
      allocator.updateVisualization();
    }
    
    function runScenario() {
      resetHeap();
      
      // Simulate a realistic allocation pattern
      const scenario = [
        { action: 'malloc', size: 32 },
        { action: 'malloc', size: 64 },
        { action: 'malloc', size: 32 },
        { action: 'malloc', size: 128 },
        { action: 'free', index: 1 },
        { action: 'free', index: 2 },
        { action: 'malloc', size: 48 },
        { action: 'malloc', size: 32 }
      ];
      
      let allocatedBlocks = [];
      let delay = 0;
      
      scenario.forEach(step => {
        setTimeout(() => {
          if (step.action === 'malloc') {
            document.getElementById('alloc-size').value = step.size;
            const blockId = allocator.malloc(step.size);
            if (blockId) allocatedBlocks.push(blockId);
          } else {
            if (allocatedBlocks[step.index]) {
              allocator.free(allocatedBlocks[step.index]);
              allocatedBlocks[step.index] = null;
            }
          }
        }, delay);
        delay += 1000;
      });
    }
    
    function switchTab(tabName) {
      // Update tab buttons
      document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.remove('active');
      });
      event.target.classList.add('active');
      
      // Update tab content
      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
      });
      document.getElementById(`${tabName}-tab`).classList.add('active');
    }
    
    // Event listeners
    document.getElementById('allocator-type').addEventListener('change', resetHeap);
    document.getElementById('heap-size').addEventListener('change', resetHeap);
    
    // Initialize on load
    window.onload = function() {
      allocator.updateVisualization();
    };
  </script>
</body>
</html>