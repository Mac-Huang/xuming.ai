<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CPU Cache Hierarchy Simulator - Xuming Huang</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" href="../stylesheet.css">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      font-family: 'Lato', sans-serif;
      margin: 0;
      padding: 20px;
      background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
      min-height: 100vh;
    }
    
    .container {
      max-width: 1600px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      padding: 30px;
    }
    
    .header {
      text-align: center;
      margin-bottom: 30px;
    }
    
    .header h1 {
      color: #1772d0;
      margin-bottom: 10px;
    }
    
    .main-layout {
      display: grid;
      grid-template-columns: 1fr 2fr 1fr;
      gap: 20px;
      margin-bottom: 30px;
    }
    
    .memory-access-panel {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 20px;
    }
    
    .cache-hierarchy {
      background: #263238;
      border-radius: 8px;
      padding: 20px;
      position: relative;
    }
    
    .stats-panel {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 20px;
    }
    
    .cache-level {
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid #4caf50;
      border-radius: 8px;
      padding: 15px;
      margin: 10px 0;
      position: relative;
    }
    
    .cache-level.l1 {
      border-color: #ffd700;
    }
    
    .cache-level.l2 {
      border-color: #ff9800;
    }
    
    .cache-level.l3 {
      border-color: #2196f3;
    }
    
    .cache-level.main-memory {
      border-color: #9c27b0;
    }
    
    .cache-title {
      color: white;
      font-weight: bold;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
    }
    
    .cache-info {
      color: #aaa;
      font-size: 11px;
    }
    
    .cache-blocks {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
      gap: 2px;
      margin-top: 10px;
    }
    
    .cache-block {
      height: 30px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid #444;
      border-radius: 2px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      color: #999;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .cache-block.valid {
      background: #4caf50;
      color: white;
      border-color: #388e3c;
    }
    
    .cache-block.dirty {
      background: #ff9800;
      color: white;
      border-color: #f57c00;
    }
    
    .cache-block.accessed {
      animation: pulse 0.5s;
      border-color: #ffd700;
      border-width: 2px;
    }
    
    .cache-block.hit {
      background: #00e676;
    }
    
    .cache-block.miss {
      background: #f44336;
    }
    
    @keyframes pulse {
      0% { transform: scale(1); background: #ffd700; }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    
    .access-input {
      width: 100%;
      padding: 10px;
      border: 2px solid #1772d0;
      border-radius: 4px;
      font-family: monospace;
      margin-bottom: 10px;
    }
    
    .access-controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-bottom: 20px;
    }
    
    .control-btn {
      padding: 10px;
      background: #1772d0;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .control-btn:hover {
      background: #1557a0;
      transform: translateY(-2px);
    }
    
    .control-btn.write {
      background: #ff9800;
    }
    
    .control-btn.write:hover {
      background: #f57c00;
    }
    
    .cache-config {
      margin: 20px 0;
    }
    
    .config-group {
      margin: 10px 0;
    }
    
    .config-label {
      font-size: 12px;
      color: #666;
      margin-bottom: 5px;
    }
    
    .config-select {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 12px;
    }
    
    .stats-grid {
      display: grid;
      gap: 15px;
    }
    
    .stat-card {
      background: white;
      border-left: 4px solid #1772d0;
      padding: 15px;
      border-radius: 4px;
    }
    
    .stat-value {
      font-size: 24px;
      font-weight: bold;
      color: #1772d0;
    }
    
    .stat-label {
      font-size: 12px;
      color: #666;
      margin-top: 5px;
    }
    
    .hit-rate-bar {
      height: 20px;
      background: #e0e0e0;
      border-radius: 10px;
      overflow: hidden;
      margin-top: 5px;
    }
    
    .hit-rate-fill {
      height: 100%;
      background: linear-gradient(90deg, #4caf50, #8bc34a);
      transition: width 0.5s;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 11px;
    }
    
    .access-pattern-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin: 20px 0;
    }
    
    .pattern-btn {
      padding: 8px;
      background: #673ab7;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    
    .pattern-btn:hover {
      background: #512da8;
    }
    
    .access-log {
      background: #1e1e1e;
      color: #4ec9b0;
      border-radius: 4px;
      padding: 10px;
      font-family: monospace;
      font-size: 11px;
      height: 150px;
      overflow-y: auto;
      margin-top: 20px;
    }
    
    .log-entry {
      margin: 2px 0;
    }
    
    .log-hit {
      color: #4caf50;
    }
    
    .log-miss {
      color: #f44336;
    }
    
    .data-flow {
      position: absolute;
      width: 4px;
      background: linear-gradient(180deg, #ffd700, #ff9800);
      opacity: 0;
      z-index: 10;
    }
    
    .data-flow.active {
      animation: dataFlow 1s ease-in-out;
    }
    
    @keyframes dataFlow {
      0% {
        opacity: 0;
        transform: translateY(0);
      }
      50% {
        opacity: 1;
      }
      100% {
        opacity: 0;
        transform: translateY(100px);
      }
    }
    
    .replacement-policy {
      margin: 20px 0;
      padding: 15px;
      background: #f5f5f5;
      border-radius: 4px;
    }
    
    .policy-option {
      margin: 5px 0;
    }
    
    .policy-option input {
      margin-right: 8px;
    }
    
    .write-policy {
      margin: 20px 0;
      padding: 15px;
      background: #f5f5f5;
      border-radius: 4px;
    }
    
    .address-breakdown {
      background: #e3f2fd;
      border-radius: 4px;
      padding: 10px;
      margin: 10px 0;
      font-family: monospace;
      font-size: 12px;
    }
    
    .address-part {
      display: inline-block;
      padding: 2px 6px;
      margin: 2px;
      border-radius: 3px;
    }
    
    .tag-bits {
      background: #4caf50;
      color: white;
    }
    
    .index-bits {
      background: #2196f3;
      color: white;
    }
    
    .offset-bits {
      background: #ff9800;
      color: white;
    }
    
    .benchmark-results {
      margin-top: 20px;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 4px;
    }
    
    .benchmark-chart {
      height: 200px;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üíæ CPU Cache Hierarchy Simulator</h1>
      <p>Interactive visualization of CPU cache behavior, replacement policies, and memory access patterns</p>
      <p><a href="../projects.html" style="color: #1772d0;">‚Üê Back to Projects</a></p>
      
      <!-- Quick Start Guide -->
      <div style="background: #e8f5e9; border: 1px solid #4caf50; border-radius: 8px; padding: 15px; margin: 20px 0; text-align: left;">
        <h3 style="color: #2e7d32; margin: 0 0 10px 0;">üöÄ Quick Start Guide</h3>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; font-size: 14px;">
          <div>
            <strong>1. Access Memory:</strong><br>
            Enter an address (0x1000) and click "üìñ Read" or "‚úèÔ∏è Write"
          </div>
          <div>
            <strong>2. Try Patterns:</strong><br>
            Click pattern buttons to simulate different access types
          </div>
          <div>
            <strong>3. Watch Cache:</strong><br>
            See cache blocks light up on hits (green) and misses (red)
          </div>
          <div>
            <strong>4. View Stats:</strong><br>
            Monitor hit rates and performance metrics on the right
          </div>
        </div>
      </div>
    </div>
    
    <div class="main-layout">
      <div class="memory-access-panel">
        <h3>Memory Access</h3>
        
        <input type="text" class="access-input" id="address-input" placeholder="Enter address (hex): 0x1234" value="0x1000">
        
        <div class="access-controls">
          <button class="control-btn" onclick="readAddress()">üìñ Read</button>
          <button class="control-btn write" onclick="writeAddress()">‚úèÔ∏è Write</button>
        </div>
        
        <div class="address-breakdown" id="address-breakdown">
          <div>Address: <span id="addr-binary">-</span></div>
          <div>
            <span class="address-part tag-bits">Tag: -</span>
            <span class="address-part index-bits">Index: -</span>
            <span class="address-part offset-bits">Offset: -</span>
          </div>
        </div>
        
        <div class="access-pattern-buttons">
          <button class="pattern-btn" onclick="runPattern('sequential')">üì∂ Sequential</button>
          <button class="pattern-btn" onclick="runPattern('stride')">ü¶ò Stride</button>
          <button class="pattern-btn" onclick="runPattern('random')">üé≤ Random</button>
          <button class="pattern-btn" onclick="runPattern('matrix')">üìä Matrix</button>
        </div>
        
        <div class="cache-config">
          <h4>Cache Configuration</h4>
          
          <div class="config-group">
            <div class="config-label">Cache Size</div>
            <select class="config-select" id="cache-size" onchange="reconfigureCache()">
              <option value="32">32 KB</option>
              <option value="64" selected>64 KB</option>
              <option value="128">128 KB</option>
              <option value="256">256 KB</option>
            </select>
          </div>
          
          <div class="config-group">
            <div class="config-label">Associativity</div>
            <select class="config-select" id="associativity" onchange="reconfigureCache()">
              <option value="1">Direct Mapped</option>
              <option value="2">2-way</option>
              <option value="4" selected>4-way</option>
              <option value="8">8-way</option>
              <option value="16">Fully Associative</option>
            </select>
          </div>
          
          <div class="config-group">
            <div class="config-label">Block Size</div>
            <select class="config-select" id="block-size" onchange="reconfigureCache()">
              <option value="32">32 bytes</option>
              <option value="64" selected>64 bytes</option>
              <option value="128">128 bytes</option>
            </select>
          </div>
        </div>
        
        <div class="replacement-policy">
          <h4>Replacement Policy</h4>
          <div class="policy-option">
            <label><input type="radio" name="policy" value="lru" checked> LRU (Least Recently Used)</label>
          </div>
          <div class="policy-option">
            <label><input type="radio" name="policy" value="fifo"> FIFO (First In First Out)</label>
          </div>
          <div class="policy-option">
            <label><input type="radio" name="policy" value="random"> Random</label>
          </div>
          <div class="policy-option">
            <label><input type="radio" name="policy" value="lfu"> LFU (Least Frequently Used)</label>
          </div>
        </div>
        
        <div class="write-policy">
          <h4>Write Policy</h4>
          <div class="policy-option">
            <label><input type="radio" name="write-policy" value="write-back" checked> Write-back</label>
          </div>
          <div class="policy-option">
            <label><input type="radio" name="write-policy" value="write-through"> Write-through</label>
          </div>
        </div>
      </div>
      
      <div class="cache-hierarchy">
        <div class="data-flow" id="data-flow"></div>
        
        <div class="cache-level l1">
          <div class="cache-title">
            <span>L1 Cache (Data)</span>
            <span class="cache-info">32 KB | 8-way | 3 cycles</span>
          </div>
          <div class="cache-blocks" id="l1-blocks"></div>
        </div>
        
        <div class="cache-level l2">
          <div class="cache-title">
            <span>L2 Cache (Unified)</span>
            <span class="cache-info">256 KB | 8-way | 12 cycles</span>
          </div>
          <div class="cache-blocks" id="l2-blocks"></div>
        </div>
        
        <div class="cache-level l3">
          <div class="cache-title">
            <span>L3 Cache (Shared)</span>
            <span class="cache-info">8 MB | 16-way | 42 cycles</span>
          </div>
          <div class="cache-blocks" id="l3-blocks"></div>
        </div>
        
        <div class="cache-level main-memory">
          <div class="cache-title">
            <span>Main Memory (DRAM)</span>
            <span class="cache-info">16 GB | ~100 cycles</span>
          </div>
          <div style="color: #aaa; text-align: center; padding: 20px;">
            Large memory space
          </div>
        </div>
      </div>
      
      <div class="stats-panel">
        <h3>Performance Statistics</h3>
        
        <div class="stats-grid">
          <div class="stat-card">
            <div class="stat-value" id="total-accesses">0</div>
            <div class="stat-label">Total Accesses</div>
          </div>
          
          <div class="stat-card">
            <div class="stat-value" id="l1-hits">0</div>
            <div class="stat-label">L1 Hits</div>
            <div class="hit-rate-bar">
              <div class="hit-rate-fill" id="l1-hit-rate" style="width: 0%">0%</div>
            </div>
          </div>
          
          <div class="stat-card">
            <div class="stat-value" id="l2-hits">0</div>
            <div class="stat-label">L2 Hits</div>
            <div class="hit-rate-bar">
              <div class="hit-rate-fill" id="l2-hit-rate" style="width: 0%">0%</div>
            </div>
          </div>
          
          <div class="stat-card">
            <div class="stat-value" id="l3-hits">0</div>
            <div class="stat-label">L3 Hits</div>
            <div class="hit-rate-bar">
              <div class="hit-rate-fill" id="l3-hit-rate" style="width: 0%">0%</div>
            </div>
          </div>
          
          <div class="stat-card">
            <div class="stat-value" id="memory-accesses">0</div>
            <div class="stat-label">Memory Accesses</div>
          </div>
          
          <div class="stat-card">
            <div class="stat-value" id="avg-latency">0</div>
            <div class="stat-label">Avg Latency (cycles)</div>
          </div>
          
          <div class="stat-card">
            <div class="stat-value" id="write-backs">0</div>
            <div class="stat-label">Write-backs</div>
          </div>
          
          <div class="stat-card">
            <div class="stat-value" id="evictions">0</div>
            <div class="stat-label">Evictions</div>
          </div>
        </div>
        
        <div class="access-log" id="access-log">
          <div class="log-entry">Cache simulator ready...</div>
        </div>
        
        <div class="benchmark-results">
          <h4>Benchmark Results</h4>
          <canvas id="benchmark-chart" class="benchmark-chart"></canvas>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Cache Simulator Implementation
    class CacheBlock {
      constructor() {
        this.valid = false;
        this.dirty = false;
        this.tag = null;
        this.data = null;
        this.lruCounter = 0;
        this.accessCount = 0;
        this.insertTime = 0;
      }
    }
    
    class CacheLevel {
      constructor(name, size, associativity, blockSize, latency) {
        this.name = name;
        this.size = size * 1024; // Convert KB to bytes
        this.associativity = associativity;
        this.blockSize = blockSize;
        this.latency = latency;
        
        this.numBlocks = this.size / this.blockSize;
        this.numSets = this.numBlocks / this.associativity;
        
        // Initialize cache storage
        this.sets = [];
        for (let i = 0; i < this.numSets; i++) {
          const set = [];
          for (let j = 0; j < this.associativity; j++) {
            set.push(new CacheBlock());
          }
          this.sets.push(set);
        }
        
        this.hits = 0;
        this.misses = 0;
        this.evictions = 0;
        this.writebacks = 0;
      }
      
      getAddressParts(address) {
        const offsetBits = Math.log2(this.blockSize);
        const indexBits = Math.log2(this.numSets);
        const tagBits = 32 - offsetBits - indexBits;
        
        const offset = address & ((1 << offsetBits) - 1);
        const index = (address >> offsetBits) & ((1 << indexBits) - 1);
        const tag = address >> (offsetBits + indexBits);
        
        return {tag, index, offset, tagBits, indexBits, offsetBits};
      }
      
      access(address, isWrite = false) {
        const {tag, index} = this.getAddressParts(address);
        const set = this.sets[index];
        
        // Check for hit
        for (let i = 0; i < set.length; i++) {
          const block = set[i];
          if (block.valid && block.tag === tag) {
            // Hit!
            this.hits++;
            block.lruCounter = Date.now();
            block.accessCount++;
            
            if (isWrite) {
              const writePolicy = document.querySelector('input[name="write-policy"]:checked').value;
              if (writePolicy === 'write-back') {
                block.dirty = true;
              }
            }
            
            return {hit: true, latency: this.latency, blockIndex: i};
          }
        }
        
        // Miss - need to fetch from lower level
        this.misses++;
        
        // Find victim block for replacement
        const victimIndex = this.selectVictim(set);
        const victim = set[victimIndex];
        
        // Handle eviction
        if (victim.valid) {
          this.evictions++;
          if (victim.dirty) {
            this.writebacks++;
          }
        }
        
        // Install new block
        victim.valid = true;
        victim.tag = tag;
        victim.dirty = isWrite && document.querySelector('input[name="write-policy"]:checked').value === 'write-back';
        victim.lruCounter = Date.now();
        victim.accessCount = 1;
        victim.insertTime = Date.now();
        
        return {hit: false, latency: this.latency, blockIndex: victimIndex};
      }
      
      selectVictim(set) {
        const policy = document.querySelector('input[name="policy"]:checked').value;
        
        // First, check for invalid blocks
        for (let i = 0; i < set.length; i++) {
          if (!set[i].valid) return i;
        }
        
        // Apply replacement policy
        switch (policy) {
          case 'lru':
            return set.reduce((min, block, i) => 
              block.lruCounter < set[min].lruCounter ? i : min, 0);
            
          case 'fifo':
            return set.reduce((min, block, i) => 
              block.insertTime < set[min].insertTime ? i : min, 0);
            
          case 'random':
            return Math.floor(Math.random() * set.length);
            
          case 'lfu':
            return set.reduce((min, block, i) => 
              block.accessCount < set[min].accessCount ? i : min, 0);
            
          default:
            return 0;
        }
      }
      
      getHitRate() {
        const total = this.hits + this.misses;
        return total > 0 ? (this.hits / total * 100).toFixed(1) : 0;
      }
    }
    
    class CacheSimulator {
      constructor() {
        this.l1 = new CacheLevel('L1', 32, 8, 64, 3);
        this.l2 = new CacheLevel('L2', 256, 8, 64, 12);
        this.l3 = new CacheLevel('L3', 8192, 16, 64, 42);
        this.memoryLatency = 100;
        
        this.totalAccesses = 0;
        this.totalLatency = 0;
        this.memoryAccesses = 0;
        
        this.initializeVisualization();
      }
      
      initializeVisualization() {
        this.renderCacheBlocks('l1-blocks', this.l1, 32);
        this.renderCacheBlocks('l2-blocks', this.l2, 64);
        this.renderCacheBlocks('l3-blocks', this.l3, 128);
      }
      
      renderCacheBlocks(elementId, cache, maxBlocks) {
        const container = document.getElementById(elementId);
        container.innerHTML = '';
        
        const blocksToShow = Math.min(cache.numBlocks, maxBlocks);
        
        for (let i = 0; i < blocksToShow; i++) {
          const block = document.createElement('div');
          block.className = 'cache-block';
          block.id = `${elementId}-${i}`;
          block.textContent = '-';
          container.appendChild(block);
        }
      }
      
      accessMemory(address, isWrite = false) {
        this.totalAccesses++;
        let totalLatency = 0;
        
        // Try L1
        const l1Result = this.l1.access(address, isWrite);
        totalLatency += l1Result.latency;
        
        if (l1Result.hit) {
          this.log(`L1 HIT: 0x${address.toString(16)} (${l1Result.latency} cycles)`, 'hit');
          this.animateCacheAccess('l1-blocks', l1Result.blockIndex, true);
        } else {
          // Try L2
          const l2Result = this.l2.access(address, isWrite);
          totalLatency += l2Result.latency;
          
          if (l2Result.hit) {
            this.log(`L2 HIT: 0x${address.toString(16)} (${totalLatency} cycles)`, 'hit');
            this.animateCacheAccess('l2-blocks', l2Result.blockIndex, true);
          } else {
            // Try L3
            const l3Result = this.l3.access(address, isWrite);
            totalLatency += l3Result.latency;
            
            if (l3Result.hit) {
              this.log(`L3 HIT: 0x${address.toString(16)} (${totalLatency} cycles)`, 'hit');
              this.animateCacheAccess('l3-blocks', l3Result.blockIndex, true);
            } else {
              // Access main memory
              totalLatency += this.memoryLatency;
              this.memoryAccesses++;
              this.log(`MEMORY: 0x${address.toString(16)} (${totalLatency} cycles)`, 'miss');
            }
            
            this.animateCacheAccess('l3-blocks', l3Result.blockIndex, false);
          }
          
          this.animateCacheAccess('l2-blocks', l2Result.blockIndex, false);
        }
        
        this.animateCacheAccess('l1-blocks', l1Result.blockIndex, false);
        
        this.totalLatency += totalLatency;
        this.updateStatistics();
        this.updateAddressBreakdown(address);
        
        return totalLatency;
      }
      
      animateCacheAccess(elementId, blockIndex, isHit) {
        const block = document.getElementById(`${elementId}-${blockIndex}`);
        if (!block) return;
        
        block.classList.remove('hit', 'miss', 'accessed');
        void block.offsetWidth; // Trigger reflow
        
        block.classList.add('accessed');
        block.classList.add(isHit ? 'hit' : 'miss');
        block.classList.add('valid');
        
        setTimeout(() => {
          block.classList.remove('hit', 'miss', 'accessed');
        }, 1000);
      }
      
      updateStatistics() {
        document.getElementById('total-accesses').textContent = this.totalAccesses;
        document.getElementById('l1-hits').textContent = this.l1.hits;
        document.getElementById('l2-hits').textContent = this.l2.hits;
        document.getElementById('l3-hits').textContent = this.l3.hits;
        document.getElementById('memory-accesses').textContent = this.memoryAccesses;
        
        const avgLatency = this.totalAccesses > 0 ? 
          (this.totalLatency / this.totalAccesses).toFixed(1) : 0;
        document.getElementById('avg-latency').textContent = avgLatency;
        
        document.getElementById('write-backs').textContent = 
          this.l1.writebacks + this.l2.writebacks + this.l3.writebacks;
        document.getElementById('evictions').textContent = 
          this.l1.evictions + this.l2.evictions + this.l3.evictions;
        
        // Update hit rates
        this.updateHitRate('l1', this.l1.getHitRate());
        this.updateHitRate('l2', this.l2.getHitRate());
        this.updateHitRate('l3', this.l3.getHitRate());
      }
      
      updateHitRate(level, rate) {
        const bar = document.getElementById(`${level}-hit-rate`);
        bar.style.width = `${rate}%`;
        bar.textContent = `${rate}%`;
      }
      
      updateAddressBreakdown(address) {
        const parts = this.l1.getAddressParts(address);
        
        const binary = address.toString(2).padStart(32, '0');
        document.getElementById('addr-binary').textContent = binary;
        
        const tagBits = binary.slice(0, parts.tagBits);
        const indexBits = binary.slice(parts.tagBits, parts.tagBits + parts.indexBits);
        const offsetBits = binary.slice(parts.tagBits + parts.indexBits);
        
        document.querySelector('.tag-bits').textContent = `Tag: ${tagBits}`;
        document.querySelector('.index-bits').textContent = `Index: ${indexBits}`;
        document.querySelector('.offset-bits').textContent = `Offset: ${offsetBits}`;
      }
      
      log(message, type = 'info') {
        const logContainer = document.getElementById('access-log');
        const entry = document.createElement('div');
        entry.className = `log-entry log-${type}`;
        entry.textContent = message;
        logContainer.appendChild(entry);
        logContainer.scrollTop = logContainer.scrollHeight;
        
        // Keep only last 50 entries
        while (logContainer.children.length > 50) {
          logContainer.removeChild(logContainer.firstChild);
        }
      }
      
      reset() {
        this.l1 = new CacheLevel('L1', 32, 8, 64, 3);
        this.l2 = new CacheLevel('L2', 256, 8, 64, 12);
        this.l3 = new CacheLevel('L3', 8192, 16, 64, 42);
        
        this.totalAccesses = 0;
        this.totalLatency = 0;
        this.memoryAccesses = 0;
        
        this.initializeVisualization();
        this.updateStatistics();
        this.log('Cache simulator reset', 'info');
      }
    }
    
    // Global simulator instance
    let simulator = new CacheSimulator();
    
    // UI Functions
    function readAddress() {
      const input = document.getElementById('address-input').value;
      const address = parseInt(input, input.startsWith('0x') ? 16 : 10);
      
      if (isNaN(address)) {
        simulator.log('Invalid address', 'miss');
        return;
      }
      
      simulator.accessMemory(address, false);
    }
    
    function writeAddress() {
      const input = document.getElementById('address-input').value;
      const address = parseInt(input, input.startsWith('0x') ? 16 : 10);
      
      if (isNaN(address)) {
        simulator.log('Invalid address', 'miss');
        return;
      }
      
      simulator.accessMemory(address, true);
    }
    
    function runPattern(pattern) {
      simulator.reset();
      
      const baseAddress = 0x1000;
      const iterations = 100;
      
      switch (pattern) {
        case 'sequential':
          // Sequential access pattern
          for (let i = 0; i < iterations; i++) {
            simulator.accessMemory(baseAddress + i * 64);
          }
          simulator.log(`Sequential pattern: ${simulator.l1.getHitRate()}% L1 hit rate`, 'info');
          break;
          
        case 'stride':
          // Stride access pattern
          const stride = 256;
          for (let i = 0; i < iterations; i++) {
            simulator.accessMemory(baseAddress + i * stride);
          }
          simulator.log(`Stride pattern: ${simulator.l1.getHitRate()}% L1 hit rate`, 'info');
          break;
          
        case 'random':
          // Random access pattern
          for (let i = 0; i < iterations; i++) {
            const randomAddr = baseAddress + Math.floor(Math.random() * 0x10000);
            simulator.accessMemory(randomAddr);
          }
          simulator.log(`Random pattern: ${simulator.l1.getHitRate()}% L1 hit rate`, 'info');
          break;
          
        case 'matrix':
          // Matrix multiplication pattern (row-major vs column-major)
          const size = 64;
          const elementSize = 4;
          
          // Row-major access
          for (let i = 0; i < size; i++) {
            for (let j = 0; j < size; j++) {
              const addr = baseAddress + (i * size + j) * elementSize;
              simulator.accessMemory(addr);
            }
          }
          simulator.log(`Matrix row-major: ${simulator.l1.getHitRate()}% L1 hit rate`, 'info');
          break;
      }
    }
    
    function reconfigureCache() {
      const size = parseInt(document.getElementById('cache-size').value);
      const associativity = parseInt(document.getElementById('associativity').value);
      const blockSize = parseInt(document.getElementById('block-size').value);
      
      simulator.l1 = new CacheLevel('L1', size, associativity, blockSize, 3);
      simulator.initializeVisualization();
      simulator.updateStatistics();
      
      simulator.log(`Cache reconfigured: ${size}KB, ${associativity}-way, ${blockSize}B blocks`, 'info');
    }
    
    // Initialize with a demo access
    setTimeout(() => {
      simulator.accessMemory(0x1000);
      simulator.accessMemory(0x1040);
      simulator.accessMemory(0x1000); // Should hit
    }, 500);
  </script>
</body>
</html>