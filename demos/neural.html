<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Neural Network Playground</title>
  <meta name="author" content="Xuming Huang">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" href="../stylesheet.css">
  <style>
    /* Clean, academic styling for neural network demo */
    .demo-container {
      display: flex;
      gap: 20px;
      margin: 20px 0;
    }
    
    .left-panel {
      flex: 1;
      min-width: 300px;
    }
    
    .right-panel {
      flex: 2;
      display: flex;
      gap: 20px;
    }
    
    canvas {
      border: 1px solid #ddd;
      background: white;
      display: block;
    }
    
    .controls {
      background: #f9f9f9;
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 15px;
    }
    
    .control-group {
      margin-bottom: 15px;
    }
    
    .control-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: 700;
    }
    
    .control-group input[type="range"] {
      width: 100%;
    }
    
    .control-group select {
      width: 100%;
      padding: 5px;
      font-family: 'EB Garamond', Georgia, serif;
      font-size: 16px;
      border: 1px solid #ddd;
      border-radius: 3px;
    }
    
    button {
      padding: 8px 15px;
      font-family: 'EB Garamond', Georgia, serif;
      font-size: 16px;
      background: white;
      border: 1px solid #ddd;
      border-radius: 3px;
      cursor: pointer;
      margin-right: 10px;
    }
    
    button:hover {
      border-color: #1772d0;
    }
    
    button.active {
      background: #1772d0;
      color: white;
      border-color: #1772d0;
    }
    
    .stats {
      background: #f9f9f9;
      padding: 10px;
      border-radius: 5px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
    }
    
    .legend {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin: 15px 0;
      font-size: 14px;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    
    .legend-color {
      width: 20px;
      height: 20px;
      border: 1px solid #333;
    }
    
    /* Network architecture display */
    .architecture {
      text-align: center;
      padding: 10px;
      background: #f9f9f9;
      border-radius: 5px;
      margin-top: 15px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
    }
  </style>
</head>

<body>
  <table style="width:100%;max-width:1200px;border:0px;border-spacing:0px;border-collapse:separate;margin-right:auto;margin-left:auto;">
    <tbody>
      <tr>
        <td style="padding:20px">
          
          <p style="text-align:center">
            <name>Neural Network Playground</name>
          </p>
          
          <p style="text-align:center; margin:20px 0;">
            <a href="../projects.html">← Back to Projects</a>
          </p>
          
          <p style="text-align:center; margin-bottom:30px;">
            Train a simple neural network to classify 2D data points. Experiment with network architecture, 
            activation functions, and learning rates while visualizing the decision boundary in real-time.
          </p>
          
          <div class="demo-container">
            <div class="left-panel">
              <div class="controls">
                <h3>Dataset</h3>
                <div class="control-group">
                  <label>Pattern:</label>
                  <select id="dataset">
                    <option value="circle">Circle</option>
                    <option value="xor">XOR</option>
                    <option value="spiral">Spiral</option>
                    <option value="gaussian">Gaussian</option>
                    <option value="linear">Linear</option>
                  </select>
                </div>
                
                <div class="control-group">
                  <label>Noise: <span id="noise-value">10%</span></label>
                  <input type="range" id="noise" min="0" max="50" value="10">
                </div>
                
                <button id="regenerate-data">Regenerate Data</button>
              </div>
              
              <div class="controls">
                <h3>Network Architecture</h3>
                <div class="control-group">
                  <label>Hidden Layers:</label>
                  <select id="layers">
                    <option value="1">1 Layer</option>
                    <option value="2" selected>2 Layers</option>
                    <option value="3">3 Layers</option>
                    <option value="4">4 Layers</option>
                  </select>
                </div>
                
                <div class="control-group">
                  <label>Neurons per Layer: <span id="neurons-value">4</span></label>
                  <input type="range" id="neurons" min="1" max="8" value="4">
                </div>
                
                <div class="control-group">
                  <label>Activation Function:</label>
                  <select id="activation">
                    <option value="relu">ReLU</option>
                    <option value="tanh">Tanh</option>
                    <option value="sigmoid">Sigmoid</option>
                    <option value="linear">Linear</option>
                  </select>
                </div>
              </div>
              
              <div class="controls">
                <h3>Training</h3>
                <div class="control-group">
                  <label>Learning Rate: <span id="lr-value">0.03</span></label>
                  <input type="range" id="learning-rate" min="0.001" max="0.1" step="0.001" value="0.03">
                </div>
                
                <div class="control-group">
                  <label>Batch Size: <span id="batch-value">10</span></label>
                  <input type="range" id="batch-size" min="1" max="50" value="10">
                </div>
                
                <button id="train" class="active">Start Training</button>
                <button id="pause">Pause</button>
                <button id="reset">Reset Network</button>
              </div>
              
              <div class="stats">
                <strong>Training Stats</strong><br>
                Epoch: <span id="epoch">0</span><br>
                Loss: <span id="loss">0.000</span><br>
                Accuracy: <span id="accuracy">0.0%</span><br>
                Training Time: <span id="time">0s</span>
              </div>
              
              <div class="architecture">
                <strong>Architecture</strong><br>
                <span id="architecture-text">Input (2) → Hidden (4) → Hidden (4) → Output (2)</span>
              </div>
            </div>
            
            <div class="right-panel">
              <div>
                <h3 style="text-align:center;">Input Data</h3>
                <canvas id="data-canvas" width="350" height="350"></canvas>
                <div class="legend">
                  <div class="legend-item">
                    <div class="legend-color" style="background:#ff6b6b;"></div>
                    <span>Class A</span>
                  </div>
                  <div class="legend-item">
                    <div class="legend-color" style="background:#4dabf7;"></div>
                    <span>Class B</span>
                  </div>
                </div>
              </div>
              
              <div>
                <h3 style="text-align:center;">Decision Boundary</h3>
                <canvas id="decision-canvas" width="350" height="350"></canvas>
                <div class="legend">
                  <div class="legend-item">
                    <div class="legend-color" style="background:#ffe0e0;"></div>
                    <span>Region A</span>
                  </div>
                  <div class="legend-item">
                    <div class="legend-color" style="background:#e0e0ff;"></div>
                    <span>Region B</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <div style="margin-top:30px;">
            <canvas id="loss-chart" width="1160" height="150"></canvas>
            <p style="text-align:center; font-size:14px; color:#666;">Training Loss Over Time</p>
          </div>
          
          <div style="margin-top:30px;">
            <heading>About This Demo</heading>
            <p>
              This interactive demonstration shows how a simple feedforward neural network learns to classify 
              2D data points. The network uses backpropagation to adjust its weights and biases, gradually 
              learning to separate the two classes.
            </p>
            
            <heading>Key Concepts</heading>
            <ul>
              <li><strong>Decision Boundary:</strong> The line or curve that separates different classes</li>
              <li><strong>Activation Functions:</strong> Non-linear functions that allow networks to learn complex patterns</li>
              <li><strong>Learning Rate:</strong> Controls how much weights are adjusted during training</li>
              <li><strong>Loss Function:</strong> Measures how wrong the network's predictions are</li>
              <li><strong>Backpropagation:</strong> Algorithm for computing gradients and updating weights</li>
            </ul>
          </div>
          
        </td>
      </tr>
    </tbody>
  </table>
  
  <script>
    // Simple neural network implementation
    class NeuralNetwork {
      constructor(layers, activation = 'relu') {
        this.layers = layers;
        this.activation = activation;
        this.weights = [];
        this.biases = [];
        
        // Initialize weights and biases
        for (let i = 0; i < layers.length - 1; i++) {
          this.weights.push(this.randomMatrix(layers[i + 1], layers[i]));
          this.biases.push(this.randomMatrix(layers[i + 1], 1));
        }
      }
      
      randomMatrix(rows, cols) {
        const matrix = [];
        for (let i = 0; i < rows; i++) {
          matrix[i] = [];
          for (let j = 0; j < cols; j++) {
            matrix[i][j] = (Math.random() - 0.5) * 2;
          }
        }
        return matrix;
      }
      
      activationFunction(x) {
        switch(this.activation) {
          case 'sigmoid':
            return 1 / (1 + Math.exp(-x));
          case 'tanh':
            return Math.tanh(x);
          case 'relu':
            return Math.max(0, x);
          case 'linear':
            return x;
          default:
            return x;
        }
      }
      
      forward(input) {
        let activation = input;
        this.activations = [activation];
        
        for (let i = 0; i < this.weights.length; i++) {
          const z = this.matrixAdd(
            this.matrixMultiply(this.weights[i], activation),
            this.biases[i]
          );
          activation = this.matrixMap(z, x => this.activationFunction(x));
          this.activations.push(activation);
        }
        
        return activation;
      }
      
      matrixMultiply(a, b) {
        const result = [];
        for (let i = 0; i < a.length; i++) {
          result[i] = [0];
          for (let j = 0; j < a[0].length; j++) {
            result[i][0] += a[i][j] * b[j][0];
          }
        }
        return result;
      }
      
      matrixAdd(a, b) {
        return a.map((row, i) => row.map((val, j) => val + b[i][j]));
      }
      
      matrixMap(matrix, fn) {
        return matrix.map(row => row.map(fn));
      }
      
      predict(x, y) {
        const input = [[x], [y]];
        const output = this.forward(input);
        return output[0][0] > output[1][0] ? 0 : 1;
      }
    }
    
    // Data generation
    function generateData(type, noise, numPoints = 200) {
      const data = [];
      
      for (let i = 0; i < numPoints; i++) {
        let x, y, label;
        
        switch(type) {
          case 'circle':
            const angle = Math.random() * Math.PI * 2;
            const r = i < numPoints / 2 ? Math.random() * 0.4 : 0.5 + Math.random() * 0.4;
            x = Math.cos(angle) * r;
            y = Math.sin(angle) * r;
            label = i < numPoints / 2 ? 0 : 1;
            break;
            
          case 'xor':
            x = Math.random() * 2 - 1;
            y = Math.random() * 2 - 1;
            label = (x * y > 0) ? 0 : 1;
            break;
            
          case 'spiral':
            const t = (i / numPoints) * 4 * Math.PI;
            const r2 = t / (4 * Math.PI);
            if (i < numPoints / 2) {
              x = Math.cos(t) * r2;
              y = Math.sin(t) * r2;
              label = 0;
            } else {
              x = Math.cos(t + Math.PI) * r2;
              y = Math.sin(t + Math.PI) * r2;
              label = 1;
            }
            break;
            
          case 'gaussian':
            if (i < numPoints / 2) {
              x = (Math.random() - 0.5) * 0.6 - 0.3;
              y = (Math.random() - 0.5) * 0.6 + 0.3;
              label = 0;
            } else {
              x = (Math.random() - 0.5) * 0.6 + 0.3;
              y = (Math.random() - 0.5) * 0.6 - 0.3;
              label = 1;
            }
            break;
            
          case 'linear':
            x = Math.random() * 2 - 1;
            y = Math.random() * 2 - 1;
            label = (y > x * 0.5 + 0.1) ? 0 : 1;
            break;
        }
        
        // Add noise
        if (Math.random() < noise / 100) {
          label = 1 - label;
        }
        
        data.push({ x, y, label });
      }
      
      return data;
    }
    
    // Canvas setup
    const dataCanvas = document.getElementById('data-canvas');
    const dataCtx = dataCanvas.getContext('2d');
    const decisionCanvas = document.getElementById('decision-canvas');
    const decisionCtx = decisionCanvas.getContext('2d');
    const lossCanvas = document.getElementById('loss-chart');
    const lossCtx = lossCanvas.getContext('2d');
    
    let data = [];
    let network = null;
    let training = false;
    let epoch = 0;
    let lossHistory = [];
    let startTime = Date.now();
    
    // Drawing functions
    function drawData() {
      dataCtx.clearRect(0, 0, dataCanvas.width, dataCanvas.height);
      
      data.forEach(point => {
        const x = (point.x + 1) * dataCanvas.width / 2;
        const y = (1 - point.y) * dataCanvas.height / 2;
        
        dataCtx.fillStyle = point.label === 0 ? '#ff6b6b' : '#4dabf7';
        dataCtx.beginPath();
        dataCtx.arc(x, y, 4, 0, Math.PI * 2);
        dataCtx.fill();
      });
    }
    
    function drawDecisionBoundary() {
      if (!network) return;
      
      const resolution = 50;
      const imageData = decisionCtx.createImageData(decisionCanvas.width, decisionCanvas.height);
      
      for (let i = 0; i < resolution; i++) {
        for (let j = 0; j < resolution; j++) {
          const x = (i / resolution) * 2 - 1;
          const y = (j / resolution) * 2 - 1;
          
          const prediction = network.predict(x, y);
          const color = prediction === 0 ? [255, 224, 224] : [224, 224, 255];
          
          const pixelX = Math.floor(i * decisionCanvas.width / resolution);
          const pixelY = Math.floor(j * decisionCanvas.height / resolution);
          const pixelW = Math.ceil(decisionCanvas.width / resolution);
          const pixelH = Math.ceil(decisionCanvas.height / resolution);
          
          for (let px = pixelX; px < pixelX + pixelW && px < decisionCanvas.width; px++) {
            for (let py = pixelY; py < pixelY + pixelH && py < decisionCanvas.height; py++) {
              const idx = (py * decisionCanvas.width + px) * 4;
              imageData.data[idx] = color[0];
              imageData.data[idx + 1] = color[1];
              imageData.data[idx + 2] = color[2];
              imageData.data[idx + 3] = 255;
            }
          }
        }
      }
      
      decisionCtx.putImageData(imageData, 0, 0);
      
      // Draw data points on top
      data.forEach(point => {
        const x = (point.x + 1) * decisionCanvas.width / 2;
        const y = (1 - point.y) * decisionCanvas.height / 2;
        
        decisionCtx.fillStyle = point.label === 0 ? '#ff6b6b' : '#4dabf7';
        decisionCtx.beginPath();
        decisionCtx.arc(x, y, 3, 0, Math.PI * 2);
        decisionCtx.fill();
      });
    }
    
    function drawLossChart() {
      lossCtx.clearRect(0, 0, lossCanvas.width, lossCanvas.height);
      
      if (lossHistory.length < 2) return;
      
      // Draw axes
      lossCtx.strokeStyle = '#ddd';
      lossCtx.beginPath();
      lossCtx.moveTo(30, 10);
      lossCtx.lineTo(30, 130);
      lossCtx.lineTo(1150, 130);
      lossCtx.stroke();
      
      // Draw loss curve
      const maxLoss = Math.max(...lossHistory);
      lossCtx.strokeStyle = '#1772d0';
      lossCtx.lineWidth = 2;
      lossCtx.beginPath();
      
      lossHistory.forEach((loss, i) => {
        const x = 30 + (i / lossHistory.length) * 1120;
        const y = 130 - (loss / maxLoss) * 110;
        
        if (i === 0) {
          lossCtx.moveTo(x, y);
        } else {
          lossCtx.lineTo(x, y);
        }
      });
      
      lossCtx.stroke();
    }
    
    // Training function
    async function train() {
      if (!network || !training) return;
      
      const learningRate = parseFloat(document.getElementById('learning-rate').value);
      const batchSize = parseInt(document.getElementById('batch-size').value);
      
      // Simple training step (simplified for demo)
      let totalLoss = 0;
      let correct = 0;
      
      for (let i = 0; i < batchSize && i < data.length; i++) {
        const point = data[Math.floor(Math.random() * data.length)];
        const input = [[point.x], [point.y]];
        const output = network.forward(input);
        
        const predicted = output[0][0] > output[1][0] ? 0 : 1;
        if (predicted === point.label) correct++;
        
        const target = point.label === 0 ? [[1], [0]] : [[0], [1]];
        const loss = Math.pow(output[0][0] - target[0][0], 2) + Math.pow(output[1][0] - target[1][0], 2);
        totalLoss += loss;
        
        // Simple weight update (gradient descent approximation for demo)
        for (let j = 0; j < network.weights.length; j++) {
          for (let k = 0; k < network.weights[j].length; k++) {
            for (let l = 0; l < network.weights[j][k].length; l++) {
              network.weights[j][k][l] += (Math.random() - 0.5) * learningRate;
            }
          }
        }
      }
      
      const avgLoss = totalLoss / batchSize;
      const accuracy = (correct / batchSize) * 100;
      
      lossHistory.push(avgLoss);
      if (lossHistory.length > 500) lossHistory.shift();
      
      epoch++;
      
      // Update UI
      document.getElementById('epoch').textContent = epoch;
      document.getElementById('loss').textContent = avgLoss.toFixed(3);
      document.getElementById('accuracy').textContent = accuracy.toFixed(1) + '%';
      document.getElementById('time').textContent = Math.floor((Date.now() - startTime) / 1000) + 's';
      
      drawDecisionBoundary();
      drawLossChart();
      
      if (training) {
        requestAnimationFrame(() => train());
      }
    }
    
    // Event handlers
    document.getElementById('regenerate-data').addEventListener('click', () => {
      const type = document.getElementById('dataset').value;
      const noise = parseInt(document.getElementById('noise').value);
      data = generateData(type, noise);
      drawData();
      drawDecisionBoundary();
    });
    
    document.getElementById('train').addEventListener('click', () => {
      training = true;
      startTime = Date.now();
      train();
    });
    
    document.getElementById('pause').addEventListener('click', () => {
      training = false;
    });
    
    document.getElementById('reset').addEventListener('click', () => {
      training = false;
      epoch = 0;
      lossHistory = [];
      
      const layers = parseInt(document.getElementById('layers').value);
      const neurons = parseInt(document.getElementById('neurons').value);
      const activation = document.getElementById('activation').value;
      
      const architecture = [2];
      for (let i = 0; i < layers; i++) {
        architecture.push(neurons);
      }
      architecture.push(2);
      
      network = new NeuralNetwork(architecture, activation);
      
      document.getElementById('architecture-text').textContent = 
        'Input (2) → ' + 
        Array(layers).fill(`Hidden (${neurons})`).join(' → ') + 
        ' → Output (2)';
      
      document.getElementById('epoch').textContent = '0';
      document.getElementById('loss').textContent = '0.000';
      document.getElementById('accuracy').textContent = '0.0%';
      document.getElementById('time').textContent = '0s';
      
      drawDecisionBoundary();
      lossCtx.clearRect(0, 0, lossCanvas.width, lossCanvas.height);
    });
    
    // Update displays
    document.getElementById('noise').addEventListener('input', (e) => {
      document.getElementById('noise-value').textContent = e.target.value + '%';
    });
    
    document.getElementById('neurons').addEventListener('input', (e) => {
      document.getElementById('neurons-value').textContent = e.target.value;
    });
    
    document.getElementById('learning-rate').addEventListener('input', (e) => {
      document.getElementById('lr-value').textContent = parseFloat(e.target.value).toFixed(3);
    });
    
    document.getElementById('batch-size').addEventListener('input', (e) => {
      document.getElementById('batch-value').textContent = e.target.value;
    });
    
    // Initialize
    data = generateData('xor', 10);
    network = new NeuralNetwork([2, 4, 4, 2], 'relu');
    drawData();
    drawDecisionBoundary();
  </script>
</body>
</html>