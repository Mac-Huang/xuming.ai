<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Neural Network Training - Xuming Huang</title>
  <meta name="author" content="Xuming Huang">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" href="../stylesheet.css">
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  
  <style>
    .control-group {
      margin: 20px 0;
      padding: 15px;
      background: #f9f9f9;
      border: 1px solid #ddd;
    }
    
    .control-group label {
      display: inline-block;
      margin-right: 20px;
      font-size: 14px;
    }
    
    .control-group input[type="range"] {
      vertical-align: middle;
      margin: 0 10px;
    }
    
    .control-group button {
      padding: 8px 15px;
      margin: 0 5px;
      background: #1772d0;
      color: white;
      border: none;
      cursor: pointer;
      font-size: 14px;
    }
    
    .control-group button:hover {
      background: #0f5aa0;
    }
    
    .control-group button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    .viz-container {
      display: flex;
      gap: 20px;
      margin: 20px 0;
    }
    
    .viz-box {
      flex: 1;
      background: #fafafa;
      border: 1px solid #ddd;
      padding: 10px;
      text-align: center;
    }
    
    .stats {
      font-family: 'Courier New', monospace;
      font-size: 14px;
      padding: 10px;
      background: #f5f5f5;
      margin: 20px 0;
    }
    
    .neuron {
      fill: #fff;
      stroke: #1772d0;
      stroke-width: 2;
    }
    
    .connection {
      stroke: #999;
      stroke-width: 1;
      fill: none;
      opacity: 0.5;
    }
    
    .connection.positive {
      stroke: #1772d0;
    }
    
    .connection.negative {
      stroke: #ff6b6b;
    }
  </style>
</head>

<body>
  <table style="width:100%;max-width:900px;border:0px;margin:auto;">
    <tbody>
      <tr>
        <td style="padding:20px;">
          <p style="text-align:right;">
            <a href="../projects.html">‚Üê Back to Projects</a>
          </p>
          
          <heading>Neural Network Training Visualizer</heading>
          <p>
            Watch how a neural network learns to classify 2D data points in real-time.
            Adjust hyperparameters and observe their effects on training dynamics.
          </p>
          
          <!-- Controls -->
          <div class="control-group">
            <div style="margin-bottom:10px;">
              <label>Learning Rate: <input type="range" id="lr" min="0.001" max="0.1" step="0.001" value="0.01">
                <span id="lr-value">0.01</span>
              </label>
              <label>Hidden Neurons: <input type="range" id="neurons" min="2" max="8" value="4">
                <span id="neurons-value">4</span>
              </label>
              <label>Activation: 
                <select id="activation">
                  <option>relu</option>
                  <option>sigmoid</option>
                  <option>tanh</option>
                </select>
              </label>
            </div>
            
            <div>
              <button onclick="generateData()">New Data</button>
              <button id="train-btn" onclick="startTraining()">Train</button>
              <button id="pause-btn" onclick="pauseTraining()" disabled>Pause</button>
              <button onclick="resetNetwork()">Reset</button>
              
              <label style="margin-left:20px;">
                Dataset:
                <select id="dataset-type">
                  <option value="circles">Circles</option>
                  <option value="xor">XOR</option>
                  <option value="spiral">Spiral</option>
                  <option value="gaussian">Gaussian</option>
                </select>
              </label>
            </div>
          </div>
          
          <!-- Visualizations -->
          <div class="viz-container">
            <!-- Data visualization -->
            <div class="viz-box">
              <h3 style="margin:0 0 10px 0; font-size:16px;">Data & Decision Boundary</h3>
              <svg id="data-plot" width="400" height="400"></svg>
            </div>
            
            <!-- Network architecture -->
            <div class="viz-box">
              <h3 style="margin:0 0 10px 0; font-size:16px;">Network Architecture</h3>
              <svg id="network-viz" width="400" height="400"></svg>
            </div>
          </div>
          
          <!-- Loss graph -->
          <div class="viz-box">
            <h3 style="margin:0 0 10px 0; font-size:16px;">Training Loss</h3>
            <svg id="loss-graph" width="860" height="200"></svg>
          </div>
          
          <!-- Statistics -->
          <div class="stats">
            Epoch: <span id="epoch">0</span> | 
            Loss: <span id="loss">0.0000</span> | 
            Accuracy: <span id="accuracy">0.0%</span> | 
            Training Time: <span id="time">0.0s</span>
          </div>
          
        </td>
      </tr>
    </tbody>
  </table>
  
  <script>
    // Global variables
    let model = null;
    let data = null;
    let isTraining = false;
    let lossHistory = [];
    let startTime = 0;
    
    // Generate dataset
    function generateData() {
      const datasetType = document.getElementById('dataset-type').value;
      const numPoints = 200;
      const points = [];
      const labels = [];
      
      switch(datasetType) {
        case 'circles':
          for (let i = 0; i < numPoints; i++) {
            const r = Math.random() * 2;
            const angle = Math.random() * 2 * Math.PI;
            const x = r * Math.cos(angle);
            const y = r * Math.sin(angle);
            points.push([x, y]);
            labels.push(r > 1 ? 1 : 0);
          }
          break;
          
        case 'xor':
          for (let i = 0; i < numPoints; i++) {
            const x = Math.random() * 4 - 2;
            const y = Math.random() * 4 - 2;
            points.push([x, y]);
            labels.push((x * y > 0) ? 1 : 0);
          }
          break;
          
        case 'spiral':
          for (let i = 0; i < numPoints / 2; i++) {
            const angle = i / (numPoints / 4) * Math.PI;
            const r = i / (numPoints / 2) * 2;
            // Class 0 spiral
            points.push([r * Math.cos(angle), r * Math.sin(angle)]);
            labels.push(0);
            // Class 1 spiral (180 degrees offset)
            points.push([r * Math.cos(angle + Math.PI), r * Math.sin(angle + Math.PI)]);
            labels.push(1);
          }
          break;
          
        case 'gaussian':
          // Two Gaussian clusters
          for (let i = 0; i < numPoints / 2; i++) {
            // Class 0
            const x0 = (Math.random() - 0.5) * 1.5 - 1;
            const y0 = (Math.random() - 0.5) * 1.5 + 1;
            points.push([x0, y0]);
            labels.push(0);
            
            // Class 1
            const x1 = (Math.random() - 0.5) * 1.5 + 1;
            const y1 = (Math.random() - 0.5) * 1.5 - 1;
            points.push([x1, y1]);
            labels.push(1);
          }
          break;
      }
      
      data = {
        points: tf.tensor2d(points),
        labels: tf.tensor1d(labels, 'int32')
      };
      
      visualizeData();
      if (model) {
        visualizeDecisionBoundary();
      }
    }
    
    // Create neural network model
    function createModel() {
      const numHidden = parseInt(document.getElementById('neurons').value);
      const activation = document.getElementById('activation').value;
      
      model = tf.sequential({
        layers: [
          tf.layers.dense({
            inputShape: [2],
            units: numHidden,
            activation: activation,
            kernelInitializer: 'glorotUniform'
          }),
          tf.layers.dense({
            units: numHidden,
            activation: activation
          }),
          tf.layers.dense({
            units: 1,
            activation: 'sigmoid'
          })
        ]
      });
      
      const lr = parseFloat(document.getElementById('lr').value);
      model.compile({
        optimizer: tf.train.adam(lr),
        loss: 'binaryCrossentropy',
        metrics: ['accuracy']
      });
      
      visualizeNetwork();
    }
    
    // Visualize data points
    function visualizeData() {
      const svg = d3.select('#data-plot');
      svg.selectAll('*').remove();
      
      if (!data) return;
      
      const width = 400;
      const height = 400;
      const margin = 20;
      
      const xScale = d3.scaleLinear()
        .domain([-3, 3])
        .range([margin, width - margin]);
      
      const yScale = d3.scaleLinear()
        .domain([-3, 3])
        .range([height - margin, margin]);
      
      // Add axes
      svg.append('g')
        .attr('transform', `translate(0,${height/2})`)
        .call(d3.axisBottom(xScale).ticks(5));
      
      svg.append('g')
        .attr('transform', `translate(${width/2},0)`)
        .call(d3.axisLeft(yScale).ticks(5));
      
      // Plot data points
      const points = data.points.arraySync();
      const labels = data.labels.arraySync();
      
      svg.selectAll('circle')
        .data(points)
        .enter()
        .append('circle')
        .attr('cx', d => xScale(d[0]))
        .attr('cy', d => yScale(d[1]))
        .attr('r', 3)
        .attr('fill', (d, i) => labels[i] === 0 ? '#1772d0' : '#ff6b6b')
        .attr('opacity', 0.7);
    }
    
    // Visualize decision boundary
    function visualizeDecisionBoundary() {
      if (!model || !data) return;
      
      const svg = d3.select('#data-plot');
      svg.selectAll('.boundary').remove();
      
      const width = 400;
      const height = 400;
      const margin = 20;
      const resolution = 50;
      
      const xScale = d3.scaleLinear()
        .domain([-3, 3])
        .range([margin, width - margin]);
      
      const yScale = d3.scaleLinear()
        .domain([-3, 3])
        .range([height - margin, margin]);
      
      // Create grid
      const grid = [];
      for (let i = 0; i < resolution; i++) {
        for (let j = 0; j < resolution; j++) {
          const x = -3 + (6 * i / resolution);
          const y = -3 + (6 * j / resolution);
          grid.push([x, y]);
        }
      }
      
      // Predict on grid
      const gridTensor = tf.tensor2d(grid);
      const predictions = model.predict(gridTensor).dataSync();
      
      // Create contour
      const contourData = [];
      for (let i = 0; i < resolution; i++) {
        contourData[i] = [];
        for (let j = 0; j < resolution; j++) {
          contourData[i][j] = predictions[i * resolution + j];
        }
      }
      
      // Draw decision boundary as background
      svg.selectAll('.boundary')
        .data(grid)
        .enter()
        .append('rect')
        .attr('class', 'boundary')
        .attr('x', (d, i) => xScale(d[0]) - 3)
        .attr('y', (d, i) => yScale(d[1]) - 3)
        .attr('width', 6)
        .attr('height', 6)
        .attr('fill', (d, i) => predictions[i] > 0.5 ? '#ff6b6b' : '#1772d0')
        .attr('opacity', 0.1);
      
      gridTensor.dispose();
    }
    
    // Visualize network architecture
    function visualizeNetwork() {
      const svg = d3.select('#network-viz');
      svg.selectAll('*').remove();
      
      if (!model) return;
      
      const width = 400;
      const height = 400;
      const layerSpacing = width / 4;
      
      // Get network structure
      const numHidden = parseInt(document.getElementById('neurons').value);
      const layers = [2, numHidden, numHidden, 1]; // input, hidden1, hidden2, output
      
      // Calculate positions
      const nodes = [];
      const connections = [];
      
      layers.forEach((count, layerIdx) => {
        const x = 50 + layerIdx * layerSpacing;
        const spacing = height / (count + 1);
        
        for (let i = 0; i < count; i++) {
          const y = spacing * (i + 1);
          nodes.push({x, y, layer: layerIdx, index: i});
          
          // Add connections to previous layer
          if (layerIdx > 0) {
            const prevCount = layers[layerIdx - 1];
            for (let j = 0; j < prevCount; j++) {
              connections.push({
                source: {x: x - layerSpacing, y: (height / (prevCount + 1)) * (j + 1)},
                target: {x, y}
              });
            }
          }
        }
      });
      
      // Draw connections
      svg.selectAll('.connection')
        .data(connections)
        .enter()
        .append('line')
        .attr('class', 'connection')
        .attr('x1', d => d.source.x)
        .attr('y1', d => d.source.y)
        .attr('x2', d => d.target.x)
        .attr('y2', d => d.target.y);
      
      // Draw nodes
      svg.selectAll('.neuron')
        .data(nodes)
        .enter()
        .append('circle')
        .attr('class', 'neuron')
        .attr('cx', d => d.x)
        .attr('cy', d => d.y)
        .attr('r', 15);
      
      // Add layer labels
      const layerNames = ['Input', 'Hidden 1', 'Hidden 2', 'Output'];
      svg.selectAll('.layer-label')
        .data(layerNames)
        .enter()
        .append('text')
        .attr('x', (d, i) => 50 + i * layerSpacing)
        .attr('y', height - 10)
        .attr('text-anchor', 'middle')
        .style('font-size', '12px')
        .text(d => d);
    }
    
    // Start training
    async function startTraining() {
      if (!model) createModel();
      if (!data) generateData();
      
      isTraining = true;
      startTime = Date.now();
      lossHistory = [];
      
      document.getElementById('train-btn').disabled = true;
      document.getElementById('pause-btn').disabled = false;
      
      const epochs = 1000;
      const batchSize = 32;
      
      for (let epoch = 0; epoch < epochs && isTraining; epoch++) {
        const history = await model.fit(data.points, data.labels, {
          batchSize: batchSize,
          epochs: 1,
          verbose: 0
        });
        
        const loss = history.history.loss[0];
        const accuracy = history.history.acc[0];
        
        lossHistory.push({epoch, loss});
        
        // Update stats
        document.getElementById('epoch').textContent = epoch + 1;
        document.getElementById('loss').textContent = loss.toFixed(4);
        document.getElementById('accuracy').textContent = (accuracy * 100).toFixed(1) + '%';
        document.getElementById('time').textContent = ((Date.now() - startTime) / 1000).toFixed(1) + 's';
        
        // Update visualizations
        if (epoch % 5 === 0) {
          visualizeDecisionBoundary();
          updateLossGraph();
        }
        
        // Small delay to allow UI updates
        await tf.nextFrame();
      }
      
      document.getElementById('train-btn').disabled = false;
      document.getElementById('pause-btn').disabled = true;
    }
    
    // Pause training
    function pauseTraining() {
      isTraining = false;
      document.getElementById('train-btn').disabled = false;
      document.getElementById('pause-btn').disabled = true;
    }
    
    // Reset network
    function resetNetwork() {
      isTraining = false;
      if (model) {
        model.dispose();
        model = null;
      }
      lossHistory = [];
      
      document.getElementById('epoch').textContent = '0';
      document.getElementById('loss').textContent = '0.0000';
      document.getElementById('accuracy').textContent = '0.0%';
      document.getElementById('time').textContent = '0.0s';
      
      document.getElementById('train-btn').disabled = false;
      document.getElementById('pause-btn').disabled = true;
      
      createModel();
      visualizeData();
      updateLossGraph();
    }
    
    // Update loss graph
    function updateLossGraph() {
      const svg = d3.select('#loss-graph');
      svg.selectAll('*').remove();
      
      if (lossHistory.length === 0) return;
      
      const width = 860;
      const height = 200;
      const margin = {top: 20, right: 30, bottom: 30, left: 50};
      
      const xScale = d3.scaleLinear()
        .domain([0, Math.max(100, lossHistory.length)])
        .range([margin.left, width - margin.right]);
      
      const yScale = d3.scaleLinear()
        .domain([0, Math.max(1, d3.max(lossHistory, d => d.loss))])
        .range([height - margin.bottom, margin.top]);
      
      // Add axes
      svg.append('g')
        .attr('transform', `translate(0,${height - margin.bottom})`)
        .call(d3.axisBottom(xScale).ticks(10));
      
      svg.append('g')
        .attr('transform', `translate(${margin.left},0)`)
        .call(d3.axisLeft(yScale).ticks(5));
      
      // Add axis labels
      svg.append('text')
        .attr('x', width / 2)
        .attr('y', height - 5)
        .attr('text-anchor', 'middle')
        .style('font-size', '12px')
        .text('Epoch');
      
      svg.append('text')
        .attr('transform', 'rotate(-90)')
        .attr('x', -height / 2)
        .attr('y', 15)
        .attr('text-anchor', 'middle')
        .style('font-size', '12px')
        .text('Loss');
      
      // Draw line
      const line = d3.line()
        .x(d => xScale(d.epoch))
        .y(d => yScale(d.loss));
      
      svg.append('path')
        .datum(lossHistory)
        .attr('fill', 'none')
        .attr('stroke', '#1772d0')
        .attr('stroke-width', 2)
        .attr('d', line);
    }
    
    // Update displays when sliders change
    document.getElementById('lr').addEventListener('input', function() {
      document.getElementById('lr-value').textContent = this.value;
    });
    
    document.getElementById('neurons').addEventListener('input', function() {
      document.getElementById('neurons-value').textContent = this.value;
      if (model) {
        model.dispose();
        model = null;
        createModel();
      }
    });
    
    document.getElementById('activation').addEventListener('change', function() {
      if (model) {
        model.dispose();
        model = null;
        createModel();
      }
    });
    
    document.getElementById('dataset-type').addEventListener('change', generateData);
    
    // Initialize on load
    window.addEventListener('load', function() {
      generateData();
      createModel();
    });
  </script>
</body>
</html>