<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>K-Map 3D Test</title>
  <style>
    body { margin: 0; padding: 20px; font-family: Arial, sans-serif; }
    #canvas3d { border: 1px solid #ccc; display: block; }
    .controls { margin: 10px 0; }
    button { padding: 10px 20px; margin: 5px; }
  </style>
</head>
<body>
  <h1>3D K-Map Test</h1>
  <div class="controls">
    <button onclick="test3Var()">3 Variables (2x2x2)</button>
    <button onclick="test4Var()">4 Variables (2x2x2x2)</button>
  </div>
  <canvas id="canvas3d" width="800" height="600"></canvas>
  <p>Drag to rotate, scroll to zoom</p>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer;
    let cube;
    let mouseDown = false;
    let mouseX = 0, mouseY = 0;
    let targetRotationX = 0, targetRotationY = 0;
    let rotationX = 0, rotationY = 0;
    let zoom = 5;

    function init() {
      // Scene setup
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f0f0);

      // Camera
      camera = new THREE.PerspectiveCamera(
        75,
        800 / 600,
        0.1,
        1000
      );
      camera.position.z = 5;

      // Renderer
      const canvas = document.getElementById('canvas3d');
      renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
      renderer.setSize(800, 600);

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
      directionalLight.position.set(5, 5, 5);
      scene.add(directionalLight);

      // Mouse controls
      canvas.addEventListener('mousedown', onMouseDown, false);
      canvas.addEventListener('mousemove', onMouseMove, false);
      canvas.addEventListener('mouseup', onMouseUp, false);
      canvas.addEventListener('mouseleave', onMouseUp, false);
      canvas.addEventListener('wheel', onWheel, false);

      animate();
    }

    function test3Var() {
      // Clear existing
      while(scene.children.length > 2) {
        scene.remove(scene.children[scene.children.length - 1]);
      }

      // Create 2x2x2 cube
      cube = new THREE.Group();

      const positions = [
        [-0.6, -0.6, -0.6], [0.6, -0.6, -0.6],
        [-0.6, 0.6, -0.6], [0.6, 0.6, -0.6],
        [-0.6, -0.6, 0.6], [0.6, -0.6, 0.6],
        [-0.6, 0.6, 0.6], [0.6, 0.6, 0.6]
      ];

      const values = [0, 1, 1, 0, 1, 1, 1, 0]; // Example values

      for (let i = 0; i < 8; i++) {
        const geometry = new THREE.BoxGeometry(0.9, 0.9, 0.9);

        let material;
        if (values[i] === 1) {
          material = new THREE.MeshPhongMaterial({
            color: 0x2196f3,
            transparent: true,
            opacity: 0.8
          });
        } else {
          material = new THREE.MeshPhongMaterial({
            color: 0xcccccc,
            transparent: true,
            opacity: 0.3
          });
        }

        const box = new THREE.Mesh(geometry, material);
        box.position.set(...positions[i]);

        // Add wireframe
        const edges = new THREE.EdgesGeometry(geometry);
        const line = new THREE.LineSegments(
          edges,
          new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 })
        );
        box.add(line);

        cube.add(box);
      }

      // Add connection lines between adjacent vertices
      const lineMaterial = new THREE.LineBasicMaterial({ color: 0x666666 });

      // Define connections
      const connections = [
        [0, 1], [2, 3], [4, 5], [6, 7], // Horizontal back/front
        [0, 2], [1, 3], [4, 6], [5, 7], // Vertical
        [0, 4], [1, 5], [2, 6], [3, 7]  // Depth
      ];

      for (let conn of connections) {
        const points = [];
        points.push(new THREE.Vector3(...positions[conn[0]]));
        points.push(new THREE.Vector3(...positions[conn[1]]));
        const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(lineGeometry, lineMaterial);
        cube.add(line);
      }

      scene.add(cube);
    }

    function test4Var() {
      // Clear existing
      while(scene.children.length > 2) {
        scene.remove(scene.children[scene.children.length - 1]);
      }

      // Create 4D hypercube projection
      cube = new THREE.Group();

      // Two 2x2x2 cubes offset
      for (let w = 0; w < 2; w++) {
        const offset = w ? 2 : -2;

        const positions = [
          [-0.5, -0.5, -0.5], [0.5, -0.5, -0.5],
          [-0.5, 0.5, -0.5], [0.5, 0.5, -0.5],
          [-0.5, -0.5, 0.5], [0.5, -0.5, 0.5],
          [-0.5, 0.5, 0.5], [0.5, 0.5, 0.5]
        ];

        for (let i = 0; i < 8; i++) {
          const geometry = new THREE.BoxGeometry(0.7, 0.7, 0.7);
          const material = new THREE.MeshPhongMaterial({
            color: w ? 0xff9800 : 0x2196f3,
            transparent: true,
            opacity: 0.7
          });

          const box = new THREE.Mesh(geometry, material);
          box.position.set(positions[i][0] + offset, positions[i][1], positions[i][2]);

          const edges = new THREE.EdgesGeometry(geometry);
          const line = new THREE.LineSegments(
            edges,
            new THREE.LineBasicMaterial({ color: 0x000000 })
          );
          box.add(line);

          cube.add(box);
        }
      }

      scene.add(cube);
    }

    function onMouseDown(event) {
      mouseDown = true;
      mouseX = event.clientX;
      mouseY = event.clientY;
    }

    function onMouseMove(event) {
      if (!mouseDown) return;

      const deltaX = event.clientX - mouseX;
      const deltaY = event.clientY - mouseY;
      mouseX = event.clientX;
      mouseY = event.clientY;

      targetRotationY += deltaX * 0.01;
      targetRotationX += deltaY * 0.01;
    }

    function onMouseUp(event) {
      mouseDown = false;
    }

    function onWheel(event) {
      event.preventDefault();
      zoom += event.deltaY * 0.01;
      zoom = Math.min(Math.max(zoom, 2), 10);
    }

    function animate() {
      requestAnimationFrame(animate);

      // Smooth rotation
      rotationX += (targetRotationX - rotationX) * 0.1;
      rotationY += (targetRotationY - rotationY) * 0.1;

      // Update camera position
      camera.position.x = zoom * Math.sin(rotationY) * Math.cos(rotationX);
      camera.position.y = zoom * Math.sin(rotationX);
      camera.position.z = zoom * Math.cos(rotationY) * Math.cos(rotationX);
      camera.lookAt(0, 0, 0);

      // Auto-rotate cube
      if (cube) {
        cube.rotation.y += 0.003;
      }

      renderer.render(scene, camera);
    }

    // Initialize on load
    window.addEventListener('load', function() {
      init();
      test3Var(); // Start with 3-variable example
    });
  </script>
</body>
</html>