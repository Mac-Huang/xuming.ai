<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>x86-64 Memory Layout Visualizer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" href="../stylesheet.css">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { background: #f8f9fa; }
    .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
    .main-card { background: #fff; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); padding: 24px; }
    .header { text-align: center; margin-bottom: 12px; }
    .header h1 { margin: 6px 0; font-size: 28px; }
    .subtitle { color: #666; }

    .layout { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
    .panel { background: #fafafa; border: 1px solid #e5e5e5; border-radius: 8px; padding: 16px; }
    .panel h3 { margin: 0 0 10px 0; }

    .controls { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .controls button { padding: 8px 14px; background: #1772d0; color: #fff; border: none; border-radius: 4px; cursor: pointer; }
    .controls button:disabled { background: #bbb; cursor: not-allowed; }
    .controls .secondary { background: #666; }
    .controls .danger { background: #c62828; }

    .toggle { display: inline-flex; align-items: center; gap: 6px; font-size: 13px; color: #444; }
    .row { display:flex; gap:16px; align-items:center; flex-wrap:wrap; margin-top:8px; }

    textarea { width: 100%; min-height: 220px; resize: vertical; font-family: Consolas, Monaco, monospace; font-size: 14px; }

    .message { margin-top: 8px; color: #c62828; min-height: 18px; }
    .step-desc { margin-top: 8px; color: #333; min-height: 18px; font-weight: 600; }

    /* Memory map */
    .mem-card { background: #fff; border: 1px solid #e0e0e0; border-radius: 8px; padding: 10px; }
    .legend { display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 10px; }
    .legend-item { display: inline-flex; align-items: center; gap: 6px; font-size: 13px; color: #444; }
    .legend-swatch { width: 14px; height: 14px; border-radius: 2px; display: inline-block; border: 1px solid #bbb; }

    .addr { font-family: Consolas, Monaco, monospace; font-size: 12px; color: #666; }
    .mem-svg { width: 100%; height: 600px; display: block; }
    .segment-label { font-size: 12px; fill: #333; font-weight: 600; }
    .block-label { font-size: 11px; fill: #111; pointer-events: none; }
    .segment-outline { stroke: #9e9e9e; stroke-width: 1; fill: none; }
    .grid-line { stroke: #eee; stroke-width: 1; }

    /* Colors */
    .seg-text { fill: #bbdefb; }
    .seg-data { fill: #c8e6c9; }
    .seg-heap { fill: #ffe0b2; }
    .seg-stack { fill: #ffcdd2; }
    .block-heap { fill: #ffb74d; }
    .block-local { fill: #ef9a9a; }
    .block-global { fill: #81c784; }
    .block-text { fill: #90caf9; }
    .freed { fill: #e0e0e0 !important; stroke-dasharray: 4 2; }

    /* Registers */
    .reg-label { font-size: 12px; fill: #111; font-weight: 700; }
    .rip-line { stroke: #1565c0; stroke-width: 2; stroke-dasharray: 4 2; }
    .rsp-line { stroke: #b71c1c; stroke-width: 2; stroke-dasharray: 4 2; }
  </style>
</head>

<body>
  <div class="container">
    <div class="main-card">
      <div class="header">
        <h1>x86-64 Memory Layout Visualizer</h1>
        <div class="subtitle">Process memory map: text, data, heap (up), stack (down). Step through a tiny program DSL to see how it maps under the hood.</div>
      </div>

      <div class="layout">
        <div class="panel">
          <h3>Program (C subset)</h3>
          <p style="color:#555; font-size: 14px;">C-like subset supported:
            <br>- Globals: <code>int g = 42;</code> <code>int arr[3];</code>
            <br>- Entry: <code>int main() { ... }</code>
            <br>- Locals: <code>int x = 1;</code> <code>int buf[8];</code>
            <br>- Heap: <code>p = malloc(32);</code> <code>free(p);</code>
            <br>- Return: <code>return 0;</code>
          </p>

          <textarea id="program"></textarea>
          <div class="controls" style="margin-top:10px;">
            <button id="loadExample">Load Example C</button>
            <button id="compileBtn">Compile</button>
            <button id="resetBtn" class="secondary">Reset</button>
          </div>
          <div class="row">
            <span class="toggle"><input type="checkbox" id="showAddrs" checked> <label for="showAddrs">Show addresses</label></span>
            <span class="toggle"><input type="checkbox" id="showRegs" checked> <label for="showRegs">Show RIP/RSP</label></span>
            <span class="toggle">Speed <input type="range" id="speed" min="100" max="1600" step="100" value="900"></span>
          </div>
          <div class="message" id="message"></div>
        </div>

        <div class="panel mem-card">
          <div class="legend">
            <span class="legend-item"><span class="legend-swatch" style="background:#bbdefb"></span>Text (code)</span>
            <span class="legend-item"><span class="legend-swatch" style="background:#c8e6c9"></span>Data (globals)</span>
            <span class="legend-item"><span class="legend-swatch" style="background:#ffe0b2"></span>Heap (up)</span>
            <span class="legend-item"><span class="legend-swatch" style="background:#ffcdd2"></span>Stack (down)</span>
          </div>
          <svg id="memSvg" class="mem-svg"></svg>
          <div class="step-desc" id="stepDesc">Step: —</div>
          <div class="controls" style="margin-top:10px;">
            <button id="prevBtn">Prev</button>
            <button id="playBtn">Play</button>
            <button id="nextBtn">Next</button>
          </div>
        </div>
      </div>

      <div class="panel" style="margin-top:20px;">
        <h3>Notes</h3>
        <ul>
          <li>This is an educational visualization. Addresses and sizes are illustrative, not exact to a specific OS.</li>
          <li>Heap grows upward; stack grows downward. Text/data are fixed at load.</li>
          <li>Locals are shown within a single <code>main</code> frame for simplicity.</li>
        </ul>
      </div>
    </div>
  </div>

  <script>
    // Address model (illustrative)
    const ADDR = {
      TEXT_BASE: 0x00400000,
      DATA_BASE: 0x00600000,
      HEAP_BASE: 0x00700000,     // grows up
      STACK_BASE: 0x7ffffff00000 // grows down (illustrative)
    };

    // Compiled state
    let compiled = null;
    let steps = [];
    let stepIndex = -1;
    let playTimer = null;

    const programEl = document.getElementById('program');
    const msgEl = document.getElementById('message');
    const stepDescEl = document.getElementById('stepDesc');
    const svg = d3.select('#memSvg');
    const width = 560, height = 600; // drawing area
    svg.attr('viewBox', `0 0 ${width} ${height}`);

    // Drawing positions
    const padding = { top: 20, right: 20, bottom: 20, left: 80 };
    const mapX = padding.left;
    const mapY = padding.top;
    const mapW = width - padding.left - padding.right;
    const mapH = height - padding.top - padding.bottom;

    // Visual proportions: text, data, heap, stack
    const TEXT_H = 60, DATA_H = 60; // fixed heights
    const HEAP_H_MAX = 220, STACK_H_MAX = 220; // grow/shrink

    // Runtime memory state (for rendering)
    function freshRuntime(comp) {
      return {
        text: { base: ADDR.TEXT_BASE, size: comp.textSize },
        data: { base: ADDR.DATA_BASE, size: comp.dataSize, globals: comp.globals },
        heap: { base: ADDR.HEAP_BASE, size: 0, blocks: [] },
        stack: { base: ADDR.STACK_BASE, size: 0, frames: [] },
        rip: ADDR.TEXT_BASE
      };
    }

    // Compile tiny DSL into structure
    function stripComments(src) {
      // remove // and /* */ comments (simple)
      return src
        .replace(/\/\*[\s\S]*?\*\//g, '')
        .replace(/(^|\n)\s*\/\/.*(?=\n|$)/g, '$1');
    }

    function compileC(src) {
      const code = stripComments(src);
      const globals = [];
      const main = [];

      // Extract main body
      const mainMatch = code.match(/int\s+main\s*\(\s*\)\s*\{([\s\S]*)\}/m);
      if (!mainMatch) throw new Error('Could not find int main() { ... }');
      const beforeMain = code.slice(0, mainMatch.index);
      const mainBody = mainMatch[1];

      // Parse globals (very limited: int name; int name = value; int name[n];)
      const globalLines = beforeMain.split(/;+/).map(s => s.trim()).filter(Boolean);
      for (const stmt of globalLines) {
        const arr = stmt.match(/^int\s+([A-Za-z_][A-Za-z0-9_]*)\s*\[(\d+)\]$/);
        if (arr) { globals.push({ name: arr[1], bytes: 4 * parseInt(arr[2], 10) }); continue; }
        const decl = stmt.match(/^int\s+([A-Za-z_][A-Za-z0-9_]*)(\s*=\s*[^;]+)?$/);
        if (decl) { globals.push({ name: decl[1], bytes: 4 }); continue; }
      }

      // Parse main body (split by semicolons)
      const lines = mainBody.split(/;+/).map(s => s.trim()).filter(Boolean);
      for (let line of lines) {
        // Remove braces/newlines inside body
        line = line.replace(/[\n\r\t]/g, ' ').trim();
        if (!line) continue;
        // Local arrays/ints
        let m = line.match(/^int\s+([A-Za-z_][A-Za-z0-9_]*)\s*\[(\d+)\]$/);
        if (m) { main.push({ op: 'alloc_local', name: m[1], bytes: 4 * parseInt(m[2], 10) }); continue; }
        m = line.match(/^int\s+([A-Za-z_][A-Za-z0-9_]*)(\s*=\s*.+)?$/);
        if (m) { main.push({ op: 'alloc_local', name: m[1], bytes: 4 }); continue; }
        // malloc: p = malloc(32)
        m = line.match(/^([A-Za-z_][A-Za-z0-9_]*)\s*=\s*malloc\s*\(\s*(\d+)\s*\)$/);
        if (m) { main.push({ op: 'malloc', name: m[1], bytes: parseInt(m[2], 10) }); continue; }
        // free(p)
        m = line.match(/^free\s*\(\s*([A-Za-z_][A-Za-z0-9_]*)\s*\)$/);
        if (m) { main.push({ op: 'free', name: m[1] }); continue; }
        // return
        if (/^return(\s+.+)?$/.test(line)) { main.push({ op: 'return' }); continue; }
        // ignore other statements for now
      }

      const textSize = Math.max(256, 16 * (main.length + 4));
      const dataSize = globals.reduce((s,g) => s + g.bytes, 0);
      return { globals, main, textSize, dataSize };
    }

    // Build step sequence from compiled program
    function buildSteps(comp) {
      const s = [];
      const runtime0 = freshRuntime(comp);
      s.push({ desc: 'Load program: map text and data', state: cloneState(runtime0) });

      // Enter main: push frame
      const rt1 = cloneState(runtime0);
      const frame = { name: 'main', base: ADDR.STACK_BASE, size: 0, locals: [] };
      rt1.stack.frames.push(frame);
      rt1.stack.size += 64; // reserve some space (saved RBP/return)
      rt1.rip += 16;
      s.push({ desc: 'Enter main: set up stack frame', state: cloneState(rt1) });

      // Execute main statements
      const rt = cloneState(rt1);
      const heapTop = () => rt.heap.base + rt.heap.size;
      const frameTop = () => rt.stack.base - rt.stack.size; // grows down

      for (const stmt of comp.main) {
        if (stmt.op === 'alloc_local') {
          const size = alignUp(stmt.bytes, 16);
          const localAddr = frameTop() - size;
          rt.stack.size += size;
          const local = { name: stmt.name, addr: localAddr, bytes: size };
          rt.stack.frames[rt.stack.frames.length - 1].locals.push(local);
          rt.rip += 16;
          s.push({ desc: `Allocate local ${stmt.name} (${stmt.bytes}B, aligned ${size}B)`, state: cloneState(rt) });
        } else if (stmt.op === 'malloc') {
          const size = alignUp(stmt.bytes, 16);
          const addr = heapTop();
          rt.heap.blocks.push({ name: stmt.name, addr, bytes: size, freed: false });
          rt.heap.size += size;
          rt.rip += 16;
          s.push({ desc: `malloc ${stmt.name} (${stmt.bytes}B) -> 0x${addr.toString(16)}`, state: cloneState(rt) });
        } else if (stmt.op === 'free') {
          const blk = rt.heap.blocks.find(b => b.name === stmt.name && !b.freed);
          if (blk) {
            blk.freed = true;
            rt.rip += 16;
            s.push({ desc: `free ${stmt.name}`, state: cloneState(rt) });
          } else {
            rt.rip += 16;
            s.push({ desc: `free ${stmt.name} (no live block found)`, state: cloneState(rt) });
          }
        } else if (stmt.op === 'return') {
          // Pop frame
          const f = rt.stack.frames.pop();
          if (f) { rt.stack.size = Math.max(0, rt.stack.size - (f.size || 0) - 64); }
          rt.rip += 16;
          s.push({ desc: 'return: tear down stack frame', state: cloneState(rt) });
        }
      }

      return s;
    }

    function alignUp(n, a) { return Math.ceil(n / a) * a; }
    function cloneState(rt) {
      return {
        text: { ...rt.text },
        data: { ...rt.data, globals: rt.data.globals.map(g => ({...g})) },
        heap: { base: rt.heap.base, size: rt.heap.size, blocks: rt.heap.blocks.map(b => ({...b})) },
        stack: { base: rt.stack.base, size: rt.stack.size, frames: rt.stack.frames.map(f => ({ name: f.name, base: f.base, size: f.size || 0, locals: (f.locals||[]).map(l => ({...l})) })) }
      };
    }

    // Render current step
    function renderStep(step) {
      stepDescEl.textContent = 'Step: ' + step.desc;
      const rt = step.state;

      svg.selectAll('*').remove();
      // Layout: low addresses at bottom — Text, Data beneath Heap; Stack near top
      const y0 = mapY;
      const bottom = y0 + mapH;
      const textY = bottom - TEXT_H - 4;
      const dataY = textY - DATA_H - 4;
      const heapY = dataY - HEAP_H_MAX - 6;
      const stackY = y0 + 10;

      // Text segment
      drawSegment(textY, TEXT_H, 'Text', 'seg-text', rt.text.base, rt.text.base + rt.text.size);
      // Data segment
      drawSegment(dataY, DATA_H, 'Data', 'seg-data', rt.data.base, rt.data.base + rt.data.size);
      // Heap
      const heapUsedH = Math.min(HEAP_H_MAX, HEAP_H_MAX * (rt.heap.size / Math.max(256, rt.heap.size)));
      drawSegment(heapY, HEAP_H_MAX, 'Heap (up)', 'seg-heap', rt.heap.base, rt.heap.base + Math.max(256, rt.heap.size));
      // Heap blocks
      let heapCursor = heapY + HEAP_H_MAX - heapUsedH;
      rt.heap.blocks.forEach(b => {
        const h = Math.max(8, HEAP_H_MAX * (b.bytes / Math.max(256, rt.heap.size)));
        svg.append('rect')
          .attr('x', mapX + 6)
          .attr('y', heapCursor)
          .attr('width', mapW - 12)
          .attr('height', h - 2)
          .attr('class', b.freed ? 'freed' : 'block-heap')
          .attr('stroke', '#8d6e63')
          .attr('stroke-width', 1)
          .transition().duration(300);
        svg.append('text')
          .attr('x', mapX + 12)
          .attr('y', heapCursor + h/2 + 4)
          .attr('class', 'block-label')
          .text(`${b.name} (${b.bytes}B)`)
          .attr('opacity', 0)
          .transition().duration(300).attr('opacity', 1);
        heapCursor += h;
      });

      // Stack
      const stackUsedH = Math.min(STACK_H_MAX, STACK_H_MAX * (rt.stack.size / Math.max(256, rt.stack.size)));
      drawSegment(stackY, STACK_H_MAX, 'Stack (down)', 'seg-stack', rt.stack.base - Math.max(256, rt.stack.size), rt.stack.base);
      // Stack locals (draw from top down)
      let stackCursor = stackY + 4;
      const locals = (rt.stack.frames[rt.stack.frames.length - 1]?.locals) || [];
      locals.forEach(l => {
        const h = Math.max(8, STACK_H_MAX * (l.bytes / Math.max(256, rt.stack.size)));
        svg.append('rect')
          .attr('x', mapX + 6)
          .attr('y', stackCursor)
          .attr('width', mapW - 12)
          .attr('height', h - 2)
          .attr('class', 'block-local')
          .attr('stroke', '#b71c1c')
          .attr('stroke-width', 1)
          .transition().duration(300);
        svg.append('text')
          .attr('x', mapX + 12)
          .attr('y', stackCursor + h/2 + 4)
          .attr('class', 'block-label')
          .text(`${l.name} (${l.bytes}B)`)
          .attr('opacity', 0)
          .transition().duration(300).attr('opacity', 1);
        stackCursor += h;
      });

      // Globals (overlay small blocks in data)
      const gCount = Math.max(1, rt.data.globals.length);
      let gCursor = dataY + 4;
      rt.data.globals.forEach(g => {
        const h = Math.max(10, (DATA_H - 8) / gCount);
        svg.append('rect')
          .attr('x', mapX + 6)
          .attr('y', gCursor)
          .attr('width', mapW - 12)
          .attr('height', h - 2)
          .attr('class', 'block-global')
          .attr('stroke', '#2e7d32')
          .attr('stroke-width', 1);
        svg.append('text')
          .attr('x', mapX + 12)
          .attr('y', gCursor + h/2 + 4)
          .attr('class', 'block-label')
          .text(`${g.name} (${g.bytes}B)`);
        gCursor += h;
      });

      // Registers (RIP within Text, RSP within Stack)
      if (document.getElementById('showRegs').checked) {
        const ripRel = Math.min(1, Math.max(0, (rt.rip - rt.text.base) / Math.max(1, rt.text.size)));
        const ripY = textY + (TEXT_H - ripRel * TEXT_H);
        svg.append('line').attr('x1', mapX).attr('x2', mapX + mapW)
          .attr('y1', ripY).attr('y2', ripY).attr('class', 'rip-line');
        svg.append('text').attr('x', mapX + 6).attr('y', ripY - 4).attr('class', 'reg-label').text('RIP');

        const rspRel = Math.min(1, Math.max(0, rt.stack.size / Math.max(256, rt.stack.size)));
        const rspY = stackY + rspRel * STACK_H_MAX;
        svg.append('line').attr('x1', mapX).attr('x2', mapX + mapW)
          .attr('y1', rspY).attr('y2', rspY).attr('class', 'rsp-line');
        svg.append('text').attr('x', mapX + 6).attr('y', rspY - 4).attr('class', 'reg-label').text('RSP');
      }
    }

    function drawSegment(y, h, name, cls, addrLo, addrHi) {
      const g = svg.append('g');
      g.append('rect')
        .attr('x', mapX)
        .attr('y', y)
        .attr('width', mapW)
        .attr('height', h)
        .attr('class', cls)
        .attr('opacity', 0.8)
        .attr('stroke', '#888')
        .attr('stroke-width', 1);
      g.append('text').attr('x', mapX + 6).attr('y', y + 16).attr('class', 'segment-label').text(name);
      if (document.getElementById('showAddrs').checked) {
        // Show high address at top, low at bottom (top of diagram = high address)
        g.append('text').attr('x', mapX + mapW - 6).attr('y', y + 14).attr('text-anchor', 'end').attr('class', 'addr').text('0x' + addrHi.toString(16));
        g.append('text').attr('x', mapX + mapW - 6).attr('y', y + h - 6).attr('text-anchor', 'end').attr('class', 'addr').text('0x' + addrLo.toString(16));
      }
      // outline
      g.append('rect')
        .attr('x', mapX)
        .attr('y', y)
        .attr('width', mapW)
        .attr('height', h)
        .attr('class', 'segment-outline');
    }

    // Controls
    document.getElementById('loadExample').onclick = () => {
      const example = `// Example: globals, locals, heap (C subset)\n\nint g = 42;\nint arr[3];\n\nint main() {\n  int x = 1;\n  int buf[8];\n  p = malloc(48);\n  free(p);\n  return 0;\n}`;
      programEl.value = example;
      msgEl.textContent = '';
    };

    document.getElementById('compileBtn').onclick = () => {
      try {
        msgEl.textContent = '';
        compiled = compileC(programEl.value);
        steps = buildSteps(compiled);
        stepIndex = 0;
        renderStep(steps[stepIndex]);
        updateNav();
      } catch (e) {
        compiled = null; steps = []; stepIndex = -1;
        msgEl.textContent = e.message;
        svg.selectAll('*').remove();
        stepDescEl.textContent = 'Step: —';
        updateNav();
      }
    };

    document.getElementById('resetBtn').onclick = () => {
      compiled = null; steps = []; stepIndex = -1; msgEl.textContent = '';
      svg.selectAll('*').remove(); stepDescEl.textContent = 'Step: —'; updateNav();
    };

    function updateNav() {
      document.getElementById('prevBtn').disabled = stepIndex <= 0;
      document.getElementById('nextBtn').disabled = stepIndex < 0 || stepIndex >= steps.length - 1;
      document.getElementById('playBtn').disabled = stepIndex < 0 || stepIndex >= steps.length - 1;
      document.getElementById('playBtn').textContent = playTimer ? 'Pause' : 'Play';
    }

    document.getElementById('prevBtn').onclick = () => {
      if (stepIndex > 0) { stepIndex--; renderStep(steps[stepIndex]); updateNav(); }
    };
    document.getElementById('nextBtn').onclick = () => {
      if (stepIndex < steps.length - 1) { stepIndex++; renderStep(steps[stepIndex]); updateNav(); }
    };
    document.getElementById('playBtn').onclick = () => {
      if (!steps.length) return;
      if (playTimer) { clearInterval(playTimer); playTimer = null; updateNav(); return; }
      const speed = parseInt(document.getElementById('speed').value, 10) || 900;
      playTimer = setInterval(() => {
        if (stepIndex < steps.length - 1) {
          stepIndex++; renderStep(steps[stepIndex]); updateNav();
        } else {
          clearInterval(playTimer); playTimer = null; updateNav();
        }
      }, speed);
      updateNav();
    };

    // Seed example initially
    document.getElementById('loadExample').click();
  </script>
</body>
</html>
