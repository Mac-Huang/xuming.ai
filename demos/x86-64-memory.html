<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>x86-64 Memory Layout Visualizer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" href="../stylesheet.css">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { background: #f8f9fa; }
    .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
    .main-card { background: #fff; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); padding: 24px; }
    .header { text-align: center; margin-bottom: 12px; }
    .header h1 { margin: 6px 0; font-size: 28px; }
    .subtitle { color: #666; }

    .layout { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
    .panel { background: #fafafa; border: 1px solid #e5e5e5; border-radius: 8px; padding: 16px; }
    .panel h3 { margin: 0 0 10px 0; }

    .controls { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .controls button { padding: 8px 14px; background: #1772d0; color: #fff; border: none; border-radius: 4px; cursor: pointer; }
    .controls button:disabled { background: #bbb; cursor: not-allowed; }
    .controls .secondary { background: #666; }
    .controls .danger { background: #c62828; }

    textarea { width: 100%; min-height: 220px; resize: vertical; font-family: Consolas, Monaco, monospace; font-size: 14px; }

    .message { margin-top: 8px; color: #c62828; min-height: 18px; }
    .step-desc { margin-top: 8px; color: #333; min-height: 18px; font-weight: 600; }

    /* Memory map */
    .mem-card { background: #fff; border: 1px solid #e0e0e0; border-radius: 8px; padding: 10px; }
    .legend { display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 10px; }
    .legend-item { display: inline-flex; align-items: center; gap: 6px; font-size: 13px; color: #444; }
    .legend-swatch { width: 14px; height: 14px; border-radius: 2px; display: inline-block; border: 1px solid #bbb; }

    .addr { font-family: Consolas, Monaco, monospace; font-size: 12px; color: #666; }
    .mem-svg { width: 100%; height: 600px; display: block; }
    .segment-label { font-size: 12px; fill: #333; font-weight: 600; }
    .block-label { font-size: 11px; fill: #111; pointer-events: none; }
    .segment-outline { stroke: #9e9e9e; stroke-width: 1; fill: none; }
    .grid-line { stroke: #eee; stroke-width: 1; }

    /* Colors */
    .seg-text { fill: #bbdefb; }
    .seg-data { fill: #c8e6c9; }
    .seg-heap { fill: #ffe0b2; }
    .seg-stack { fill: #ffcdd2; }
    .block-heap { fill: #ffb74d; }
    .block-local { fill: #ef9a9a; }
    .block-global { fill: #81c784; }
    .block-text { fill: #90caf9; }
    .freed { fill: #e0e0e0 !important; stroke-dasharray: 4 2; }
  </style>
</head>

<body>
  <div class="container">
    <div class="main-card">
      <div class="header">
        <h1>x86-64 Memory Layout Visualizer</h1>
        <div class="subtitle">Process memory map: text, data, heap (up), stack (down). Step through a tiny program DSL to see how it maps under the hood.</div>
      </div>

      <div class="layout">
        <div class="panel">
          <h3>Program (Tiny DSL)</h3>
          <p style="color:#555; font-size: 14px;">Syntax examples:
            <br>- <code>global int g = 42</code>
            <br>- <code>global int arr[3]</code>
            <br>- <code>main:</code>
            <br>- <code>  int x = 1</code>
            <br>- <code>  int buf[8]</code>
            <br>- <code>  malloc p 32</code>
            <br>- <code>  free p</code>
            <br>- <code>  return</code>
          </p>

          <textarea id="program"></textarea>
          <div class="controls" style="margin-top:10px;">
            <button id="loadExample">Load Example</button>
            <button id="compileBtn">Compile</button>
            <button id="resetBtn" class="secondary">Reset</button>
          </div>
          <div class="message" id="message"></div>
        </div>

        <div class="panel mem-card">
          <div class="legend">
            <span class="legend-item"><span class="legend-swatch" style="background:#bbdefb"></span>Text (code)</span>
            <span class="legend-item"><span class="legend-swatch" style="background:#c8e6c9"></span>Data (globals)</span>
            <span class="legend-item"><span class="legend-swatch" style="background:#ffe0b2"></span>Heap (up)</span>
            <span class="legend-item"><span class="legend-swatch" style="background:#ffcdd2"></span>Stack (down)</span>
          </div>
          <svg id="memSvg" class="mem-svg"></svg>
          <div class="step-desc" id="stepDesc">Step: —</div>
          <div class="controls" style="margin-top:10px;">
            <button id="prevBtn">Prev</button>
            <button id="playBtn">Play</button>
            <button id="nextBtn">Next</button>
          </div>
        </div>
      </div>

      <div class="panel" style="margin-top:20px;">
        <h3>Notes</h3>
        <ul>
          <li>This is an educational visualization. Addresses and sizes are illustrative, not exact to a specific OS.</li>
          <li>Heap grows upward; stack grows downward. Text/data are fixed at load.</li>
          <li>Locals are shown within a single <code>main</code> frame for simplicity.</li>
        </ul>
      </div>
    </div>
  </div>

  <script>
    // Address model (illustrative)
    const ADDR = {
      TEXT_BASE: 0x00400000,
      DATA_BASE: 0x00600000,
      HEAP_BASE: 0x00700000,     // grows up
      STACK_BASE: 0x7ffffff00000 // grows down (illustrative)
    };

    // Compiled state
    let compiled = null;
    let steps = [];
    let stepIndex = -1;
    let playTimer = null;

    const programEl = document.getElementById('program');
    const msgEl = document.getElementById('message');
    const stepDescEl = document.getElementById('stepDesc');
    const svg = d3.select('#memSvg');
    const width = 560, height = 600; // drawing area
    svg.attr('viewBox', `0 0 ${width} ${height}`);

    // Drawing positions
    const padding = { top: 20, right: 20, bottom: 20, left: 80 };
    const mapX = padding.left;
    const mapY = padding.top;
    const mapW = width - padding.left - padding.right;
    const mapH = height - padding.top - padding.bottom;

    // Visual proportions: text, data, heap, stack
    const TEXT_H = 60, DATA_H = 60; // fixed heights
    const HEAP_H_MAX = 220, STACK_H_MAX = 220; // grow/shrink

    // Runtime memory state (for rendering)
    function freshRuntime(comp) {
      return {
        text: { base: ADDR.TEXT_BASE, size: comp.textSize },
        data: { base: ADDR.DATA_BASE, size: comp.dataSize, globals: comp.globals },
        heap: { base: ADDR.HEAP_BASE, size: 0, blocks: [] },
        stack: { base: ADDR.STACK_BASE, size: 0, frames: [] },
      };
    }

    // Compile tiny DSL into structure
    function compileDSL(src) {
      const lines = src.split(/\r?\n/).map(l => l.trim()).filter(l => l.length && !l.startsWith('#'));
      const globals = []; // {name, size}
      const main = [];
      let inMain = false;

      function parseDecl(line, isGlobal) {
        // global int g = 42
        // global int arr[3]
        // int x = 1
        // int buf[8]
        const mArr = line.match(/^(?:global\s+)?int\s+([A-Za-z_][A-Za-z0-9_]*)\s*\[(\d+)\]\s*$/);
        if (mArr) {
          const name = mArr[1];
          const len = parseInt(mArr[2], 10);
          return { type: isGlobal ? 'global_arr' : 'local_arr', name, bytes: 4*len };
        }
        const mInit = line.match(/^(?:global\s+)?int\s+([A-Za-z_][A-Za-z0-9_]*)\s*(?:=\s*([^\s]+))?\s*$/);
        if (mInit) {
          const name = mInit[1];
          return { type: isGlobal ? 'global_int' : 'local_int', name, bytes: 4 };
        }
        return null;
      }

      for (const line of lines) {
        if (line.toLowerCase() === 'main:' || line.toLowerCase() === 'function main' || line.toLowerCase() === 'fn main') {
          inMain = true; continue;
        }
        if (!inMain) {
          if (line.startsWith('global ')) {
            const decl = parseDecl(line, true);
            if (!decl) throw new Error(`Unrecognized global declaration: ${line}`);
            globals.push({ name: decl.name, bytes: decl.bytes });
          } else {
            throw new Error(`Only global declarations allowed before main. Found: ${line}`);
          }
        } else {
          // main body statements
          if (line.startsWith('int ')) {
            const decl = parseDecl(line, false);
            if (!decl) throw new Error(`Unrecognized local declaration: ${line}`);
            main.push({ op: decl.type === 'local_arr' ? 'alloc_local' : 'alloc_local', name: decl.name, bytes: decl.bytes });
          } else if (line.startsWith('malloc ')) {
            // malloc p 32
            const mm = line.match(/^malloc\s+([A-Za-z_][A-Za-z0-9_]*)\s+(\d+)$/);
            if (!mm) throw new Error(`Malformed malloc: ${line}`);
            main.push({ op: 'malloc', name: mm[1], bytes: parseInt(mm[2], 10) });
          } else if (line.startsWith('free ')) {
            const mf = line.match(/^free\s+([A-Za-z_][A-Za-z0-9_]*)$/);
            if (!mf) throw new Error(`Malformed free: ${line}`);
            main.push({ op: 'free', name: mf[1] });
          } else if (/^return$/i.test(line)) {
            main.push({ op: 'return' });
          } else {
            throw new Error(`Unrecognized statement in main: ${line}`);
          }
        }
      }

      // Derive sizes
      const textSize = Math.max(256, 16 * (main.length + 4)); // simple model
      const dataSize = globals.reduce((s,g) => s + g.bytes, 0);
      return { globals, main, textSize, dataSize };
    }

    // Build step sequence from compiled program
    function buildSteps(comp) {
      const s = [];
      const runtime0 = freshRuntime(comp);
      s.push({ desc: 'Load program: map text and data', state: cloneState(runtime0) });

      // Enter main: push frame
      const rt1 = cloneState(runtime0);
      const frame = { name: 'main', base: ADDR.STACK_BASE, size: 0, locals: [] };
      rt1.stack.frames.push(frame);
      rt1.stack.size += 64; // reserve some space (saved RBP/return)
      s.push({ desc: 'Enter main: set up stack frame', state: cloneState(rt1) });

      // Execute main statements
      const rt = cloneState(rt1);
      const heapTop = () => rt.heap.base + rt.heap.size;
      const frameTop = () => rt.stack.base - rt.stack.size; // grows down

      for (const stmt of comp.main) {
        if (stmt.op === 'alloc_local') {
          const size = alignUp(stmt.bytes, 16);
          const localAddr = frameTop() - size;
          rt.stack.size += size;
          const local = { name: stmt.name, addr: localAddr, bytes: size };
          rt.stack.frames[rt.stack.frames.length - 1].locals.push(local);
          s.push({ desc: `Allocate local ${stmt.name} (${stmt.bytes}B, aligned ${size}B)`, state: cloneState(rt) });
        } else if (stmt.op === 'malloc') {
          const size = alignUp(stmt.bytes, 16);
          const addr = heapTop();
          rt.heap.blocks.push({ name: stmt.name, addr, bytes: size, freed: false });
          rt.heap.size += size;
          s.push({ desc: `malloc ${stmt.name} (${stmt.bytes}B) -> 0x${addr.toString(16)}`, state: cloneState(rt) });
        } else if (stmt.op === 'free') {
          const blk = rt.heap.blocks.find(b => b.name === stmt.name && !b.freed);
          if (blk) {
            blk.freed = true;
            s.push({ desc: `free ${stmt.name}`, state: cloneState(rt) });
          } else {
            s.push({ desc: `free ${stmt.name} (no live block found)`, state: cloneState(rt) });
          }
        } else if (stmt.op === 'return') {
          // Pop frame
          const f = rt.stack.frames.pop();
          if (f) { rt.stack.size = Math.max(0, rt.stack.size - (f.size || 0) - 64); }
          s.push({ desc: 'return: tear down stack frame', state: cloneState(rt) });
        }
      }

      return s;
    }

    function alignUp(n, a) { return Math.ceil(n / a) * a; }
    function cloneState(rt) {
      return {
        text: { ...rt.text },
        data: { ...rt.data, globals: rt.data.globals.map(g => ({...g})) },
        heap: { base: rt.heap.base, size: rt.heap.size, blocks: rt.heap.blocks.map(b => ({...b})) },
        stack: { base: rt.stack.base, size: rt.stack.size, frames: rt.stack.frames.map(f => ({ name: f.name, base: f.base, size: f.size || 0, locals: (f.locals||[]).map(l => ({...l})) })) }
      };
    }

    // Render current step
    function renderStep(step) {
      stepDescEl.textContent = 'Step: ' + step.desc;
      const rt = step.state;

      svg.selectAll('*').remove();
      // Layout rectangles: bottom-up text, data, heap; top-down stack
      const y0 = mapY;
      const textY = y0 + mapH - TEXT_H - DATA_H - HEAP_H_MAX - 10;
      const dataY = textY + TEXT_H + 5;
      const heapY = dataY + DATA_H + 5;
      const stackY = y0 + 10;

      // Text segment
      drawSegment(textY, TEXT_H, 'Text', 'seg-text', rt.text.base, rt.text.base + rt.text.size);
      // Data segment
      drawSegment(dataY, DATA_H, 'Data', 'seg-data', rt.data.base, rt.data.base + rt.data.size);
      // Heap
      const heapUsedH = Math.min(HEAP_H_MAX, HEAP_H_MAX * (rt.heap.size / Math.max(256, rt.heap.size)));
      drawSegment(heapY, HEAP_H_MAX, 'Heap (up)', 'seg-heap', rt.heap.base, rt.heap.base + Math.max(256, rt.heap.size));
      // Heap blocks
      let heapCursor = heapY + HEAP_H_MAX - heapUsedH;
      rt.heap.blocks.forEach(b => {
        const h = Math.max(8, HEAP_H_MAX * (b.bytes / Math.max(256, rt.heap.size)));
        svg.append('rect')
          .attr('x', mapX + 6)
          .attr('y', heapCursor)
          .attr('width', mapW - 12)
          .attr('height', h - 2)
          .attr('class', b.freed ? 'freed' : 'block-heap')
          .attr('stroke', '#8d6e63')
          .attr('stroke-width', 1);
        svg.append('text')
          .attr('x', mapX + 12)
          .attr('y', heapCursor + h/2 + 4)
          .attr('class', 'block-label')
          .text(`${b.name} (${b.bytes}B)`);
        heapCursor += h;
      });

      // Stack
      const stackUsedH = Math.min(STACK_H_MAX, STACK_H_MAX * (rt.stack.size / Math.max(256, rt.stack.size)));
      drawSegment(stackY, STACK_H_MAX, 'Stack (down)', 'seg-stack', rt.stack.base - Math.max(256, rt.stack.size), rt.stack.base);
      // Stack locals (draw from top down)
      let stackCursor = stackY + 4;
      const locals = (rt.stack.frames[rt.stack.frames.length - 1]?.locals) || [];
      locals.forEach(l => {
        const h = Math.max(8, STACK_H_MAX * (l.bytes / Math.max(256, rt.stack.size)));
        svg.append('rect')
          .attr('x', mapX + 6)
          .attr('y', stackCursor)
          .attr('width', mapW - 12)
          .attr('height', h - 2)
          .attr('class', 'block-local')
          .attr('stroke', '#b71c1c')
          .attr('stroke-width', 1);
        svg.append('text')
          .attr('x', mapX + 12)
          .attr('y', stackCursor + h/2 + 4)
          .attr('class', 'block-label')
          .text(`${l.name} (${l.bytes}B)`);
        stackCursor += h;
      });

      // Globals (overlay small blocks in data)
      const gCount = Math.max(1, rt.data.globals.length);
      let gCursor = dataY + 4;
      rt.data.globals.forEach(g => {
        const h = Math.max(10, (DATA_H - 8) / gCount);
        svg.append('rect')
          .attr('x', mapX + 6)
          .attr('y', gCursor)
          .attr('width', mapW - 12)
          .attr('height', h - 2)
          .attr('class', 'block-global')
          .attr('stroke', '#2e7d32')
          .attr('stroke-width', 1);
        svg.append('text')
          .attr('x', mapX + 12)
          .attr('y', gCursor + h/2 + 4)
          .attr('class', 'block-label')
          .text(`${g.name} (${g.bytes}B)`);
        gCursor += h;
      });
    }

    function drawSegment(y, h, name, cls, addrLo, addrHi) {
      svg.append('rect')
        .attr('x', mapX)
        .attr('y', y)
        .attr('width', mapW)
        .attr('height', h)
        .attr('class', cls)
        .attr('opacity', 0.8)
        .attr('stroke', '#888')
        .attr('stroke-width', 1);
      svg.append('text').attr('x', mapX + 6).attr('y', y + 16).attr('class', 'segment-label').text(name);
      svg.append('text').attr('x', mapX + mapW - 6).attr('y', y + 14).attr('text-anchor', 'end').attr('class', 'addr').text('0x' + addrLo.toString(16));
      svg.append('text').attr('x', mapX + mapW - 6).attr('y', y + h - 6).attr('text-anchor', 'end').attr('class', 'addr').text('0x' + addrHi.toString(16));
      // outline
      svg.append('rect')
        .attr('x', mapX)
        .attr('y', y)
        .attr('width', mapW)
        .attr('height', h)
        .attr('class', 'segment-outline');
    }

    // Controls
    document.getElementById('loadExample').onclick = () => {
      const example = `# Example: globals, locals, heap
global int g = 42
global int arr[3]

main:
  int x = 1
  int buf[8]
  malloc p 48
  free p
  return`;
      programEl.value = example;
      msgEl.textContent = '';
    };

    document.getElementById('compileBtn').onclick = () => {
      try {
        msgEl.textContent = '';
        compiled = compileDSL(programEl.value);
        steps = buildSteps(compiled);
        stepIndex = 0;
        renderStep(steps[stepIndex]);
        updateNav();
      } catch (e) {
        compiled = null; steps = []; stepIndex = -1;
        msgEl.textContent = e.message;
        svg.selectAll('*').remove();
        stepDescEl.textContent = 'Step: —';
        updateNav();
      }
    };

    document.getElementById('resetBtn').onclick = () => {
      compiled = null; steps = []; stepIndex = -1; msgEl.textContent = '';
      svg.selectAll('*').remove(); stepDescEl.textContent = 'Step: —'; updateNav();
    };

    function updateNav() {
      document.getElementById('prevBtn').disabled = stepIndex <= 0;
      document.getElementById('nextBtn').disabled = stepIndex < 0 || stepIndex >= steps.length - 1;
      document.getElementById('playBtn').disabled = stepIndex < 0 || stepIndex >= steps.length - 1;
      document.getElementById('playBtn').textContent = playTimer ? 'Pause' : 'Play';
    }

    document.getElementById('prevBtn').onclick = () => {
      if (stepIndex > 0) { stepIndex--; renderStep(steps[stepIndex]); updateNav(); }
    };
    document.getElementById('nextBtn').onclick = () => {
      if (stepIndex < steps.length - 1) { stepIndex++; renderStep(steps[stepIndex]); updateNav(); }
    };
    document.getElementById('playBtn').onclick = () => {
      if (!steps.length) return;
      if (playTimer) { clearInterval(playTimer); playTimer = null; updateNav(); return; }
      playTimer = setInterval(() => {
        if (stepIndex < steps.length - 1) {
          stepIndex++; renderStep(steps[stepIndex]); updateNav();
        } else {
          clearInterval(playTimer); playTimer = null; updateNav();
        }
      }, 900);
      updateNav();
    };

    // Seed example initially
    document.getElementById('loadExample').click();
  </script>
</body>
</html>

