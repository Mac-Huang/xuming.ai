<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Graph Algorithms Playground</title>
  <meta name="author" content="Xuming Huang">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" href="../stylesheet.css">
  <style>
    /* Clean, academic styling */
    #graph-canvas {
      border: 2px solid #ddd;
      background: white;
      cursor: crosshair;
      display: block;
      margin: 20px auto;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    #graph-canvas.add-node-mode {
      cursor: crosshair;
    }
    
    #graph-canvas.add-edge-mode {
      cursor: pointer;
    }
    
    #graph-canvas.delete-mode {
      cursor: not-allowed;
    }
    
    .controls {
      text-align: center;
      margin: 15px 0;
      padding: 10px;
      background: #f9f9f9;
      border-radius: 5px;
    }
    
    .controls button, .controls select {
      margin: 3px;
      padding: 6px 12px;
      font-family: 'EB Garamond', Georgia, serif;
      font-size: 14px;
      background: white;
      color: #333;
      border: 2px solid #ddd;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .controls button:hover:not(:disabled), .controls select:hover {
      border-color: #1772d0;
      background: #1772d0;
      color: white;
    }
    
    .controls button.active {
      background: #1772d0;
      color: white;
      border-color: #1772d0;
      font-weight: bold;
    }
    
    .controls button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .mode-indicator {
      display: inline-block;
      padding: 8px 15px;
      background: #ffe066;
      border-radius: 5px;
      font-weight: bold;
      margin: 10px;
    }
    
    .info-panel {
      background: #f9f9f9;
      padding: 15px;
      border-radius: 5px;
      margin: 20px 0;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      border-left: 4px solid #1772d0;
    }
    
    .legend {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin: 15px 0;
      padding: 10px;
      background: white;
      border: 1px solid #ddd;
      border-radius: 5px;
      font-size: 14px;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    
    .legend-color {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 2px solid #333;
    }
    
    .instructions-box {
      background: #e3f2fd;
      padding: 15px;
      border-radius: 5px;
      margin: 20px 0;
    }
    
    .presets {
      margin: 15px 0;
      text-align: center;
    }
    
    .presets button {
      margin: 3px;
      padding: 5px 10px;
      background: #e8f5e9;
      color: #2e7d32;
      border: 1px solid #4caf50;
      border-radius: 3px;
      cursor: pointer;
      font-size: 13px;
    }
    
    .presets button:hover {
      background: #4caf50;
      color: white;
    }
  </style>
</head>

<body>
  <table style="width:100%;max-width:900px;border:0px;border-spacing:0px;border-collapse:separate;margin-right:auto;margin-left:auto;">
    <tbody>
      <tr>
        <td style="padding:20px">
          
          <p style="text-align:center">
            <name>Graph Algorithms Playground</name>
          </p>
          
          <p style="text-align:center; margin:20px 0;">
            <a href="../projects.html">‚Üê Back to Projects</a>
          </p>
          
          <div class="instructions-box">
            <strong>Current Mode:</strong> <span id="mode-display" class="mode-indicator">Add Node</span>
            <p style="margin: 10px 0 0 0; font-size: 14px;" id="mode-instruction">Click on empty space to add a new node</p>
          </div>
          
          <div class="presets">
            <strong>Load Example:</strong>
            <button onclick="loadPreset('binary-tree')">Binary Tree</button>
            <button onclick="loadPreset('grid')">Grid Graph</button>
            <button onclick="loadPreset('complete')">Complete Graph</button>
            <button onclick="loadPreset('weighted')">Weighted Graph</button>
          </div>
          
          <div class="controls">
            <strong>Graph Building:</strong>
            <button id="add-node" class="active">‚ûï Add Node</button>
            <button id="add-edge">üîó Add Edge</button>
            <button id="set-start">üö© Set Start</button>
            <button id="set-end">üéØ Set End</button>
            <button id="delete">üóëÔ∏è Delete</button>
            <button id="clear">‚ùå Clear All</button>
          </div>
          
          <div class="controls">
            <strong>Algorithm:</strong>
            <select id="algorithm">
              <option value="bfs">Breadth-First Search (BFS)</option>
              <option value="dfs">Depth-First Search (DFS)</option>
              <option value="dijkstra">Dijkstra's Shortest Path</option>
              <option value="astar">A* Pathfinding</option>
              <option value="kruskal">Kruskal's MST</option>
              <option value="prim">Prim's MST</option>
            </select>
            
            <button id="run-algorithm">‚ñ∂Ô∏è Run</button>
            <button id="step-algorithm">‚è≠Ô∏è Step</button>
            <button id="pause-algorithm">‚è∏Ô∏è Pause</button>
            <button id="reset-algorithm">üîÑ Reset</button>
            
            <label style="margin-left:10px;">
              Speed: <input type="range" id="speed" min="100" max="2000" value="500" style="width:100px;">
              <span id="speed-display">500ms</span>
            </label>
          </div>
          
          <canvas id="graph-canvas" width="700" height="400"></canvas>
          
          <div class="legend">
            <div class="legend-item">
              <div class="legend-color" style="background:#ddd;"></div>
              <span>Unvisited</span>
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background:#ffe066;"></div>
              <span>Current/Frontier</span>
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background:#51cf66;"></div>
              <span>Visited</span>
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background:#ff6b6b;"></div>
              <span>Start Node</span>
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background:#4dabf7;"></div>
              <span>End Node</span>
            </div>
            <div class="legend-item">
              <div style="width:20px;height:3px;background:#1772d0;"></div>
              <span>Path</span>
            </div>
          </div>
          
          <div class="info-panel">
            <strong>Algorithm Status:</strong> <span id="status">Ready</span><br>
            <strong>Nodes Visited:</strong> <span id="nodes-visited">0</span><br>
            <strong>Path Length:</strong> <span id="path-length">-</span><br>
            <strong>Time Complexity:</strong> <span id="complexity">-</span>
          </div>
          
          <div style="margin-top:20px; display:flex; gap:20px;">
            <div style="flex:1;">
              <heading style="font-size:16px;">Quick Instructions</heading>
              <ul style="font-size:13px; margin:10px 0;">
                <li>Click empty space to add nodes</li>
                <li>Click two nodes to connect</li>
                <li>Use Set Start/End buttons</li>
                <li>Load presets for quick start</li>
              </ul>
            </div>
            <div style="flex:1;">
              <heading style="font-size:16px;">Algorithms</heading>
              <ul style="font-size:13px; margin:10px 0;">
                <li><strong>BFS/DFS:</strong> Graph traversal</li>
                <li><strong>Dijkstra:</strong> Shortest path</li>
                <li><strong>Kruskal/Prim:</strong> Min spanning tree</li>
              </ul>
            </div>
          </div>
          
        </td>
      </tr>
    </tbody>
  </table>
  
  <script>
    // Graph data structure
    class Graph {
      constructor() {
        this.nodes = [];
        this.edges = [];
        this.startNode = null;
        this.endNode = null;
        this.nodeIdCounter = 0;
      }
      
      addNode(x, y) {
        const node = {
          id: this.nodeIdCounter++,
          x: x,
          y: y,
          visited: false,
          distance: Infinity,
          parent: null,
          color: '#ddd'
        };
        this.nodes.push(node);
        return node;
      }
      
      addEdge(node1, node2, weight = 1) {
        const edge = {
          from: node1,
          to: node2,
          weight: weight,
          color: '#999'
        };
        this.edges.push(edge);
        return edge;
      }
      
      getNeighbors(node) {
        const neighbors = [];
        this.edges.forEach(edge => {
          if (edge.from === node) {
            neighbors.push({ node: edge.to, weight: edge.weight });
          } else if (edge.to === node) {
            neighbors.push({ node: edge.from, weight: edge.weight });
          }
        });
        return neighbors;
      }
      
      reset() {
        this.nodes.forEach(node => {
          node.visited = false;
          node.distance = Infinity;
          node.parent = null;
          node.color = '#ddd';
        });
        this.edges.forEach(edge => {
          edge.color = '#999';
        });
      }
    }
    
    // Canvas setup
    const canvas = document.getElementById('graph-canvas');
    const ctx = canvas.getContext('2d');
    const graph = new Graph();
    
    let mode = 'add-node';
    let selectedNode = null;
    let running = false;
    let speed = 500;
    
    // Drawing functions
    function drawGraph() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw edges
      graph.edges.forEach(edge => {
        ctx.strokeStyle = edge.color;
        ctx.lineWidth = edge.color === '#1772d0' ? 3 : 1;
        ctx.beginPath();
        ctx.moveTo(edge.from.x, edge.from.y);
        ctx.lineTo(edge.to.x, edge.to.y);
        ctx.stroke();
        
        // Draw weight
        if (edge.weight !== 1) {
          const midX = (edge.from.x + edge.to.x) / 2;
          const midY = (edge.from.y + edge.to.y) / 2;
          ctx.fillStyle = 'white';
          ctx.fillRect(midX - 10, midY - 10, 20, 20);
          ctx.fillStyle = 'black';
          ctx.font = '14px Courier New';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(edge.weight, midX, midY);
        }
      });
      
      // Draw nodes
      graph.nodes.forEach(node => {
        ctx.fillStyle = node === graph.startNode ? '#ff6b6b' : 
                        node === graph.endNode ? '#4dabf7' : 
                        node.color;
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(node.x, node.y, 20, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        // Draw node ID
        ctx.fillStyle = node.color === '#ddd' ? 'black' : 'white';
        ctx.font = '14px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(node.id, node.x, node.y);
      });
    }
    
    // Update mode display
    function updateModeDisplay() {
      const modeDisplay = document.getElementById('mode-display');
      const modeInstruction = document.getElementById('mode-instruction');
      const canvas = document.getElementById('graph-canvas');
      
      // Remove all mode classes
      canvas.classList.remove('add-node-mode', 'add-edge-mode', 'delete-mode');
      
      switch(mode) {
        case 'add-node':
          modeDisplay.textContent = 'Add Node';
          modeInstruction.textContent = 'Click on empty space to add a new node';
          canvas.classList.add('add-node-mode');
          break;
        case 'add-edge':
          modeDisplay.textContent = 'Add Edge';
          modeInstruction.textContent = selectedNode ? 
            'Click another node to connect' : 
            'Click first node to start edge';
          canvas.classList.add('add-edge-mode');
          break;
        case 'set-start':
          modeDisplay.textContent = 'Set Start Node';
          modeInstruction.textContent = 'Click a node to set as start (red)';
          break;
        case 'set-end':
          modeDisplay.textContent = 'Set End Node';
          modeInstruction.textContent = 'Click a node to set as destination (blue)';
          break;
        case 'delete':
          modeDisplay.textContent = 'Delete Mode';
          modeInstruction.textContent = 'Click nodes or edges to delete them';
          canvas.classList.add('delete-mode');
          break;
      }
    }
    
    // Event handlers
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      // Find clicked node
      const clickedNode = graph.nodes.find(node => {
        const dx = node.x - x;
        const dy = node.y - y;
        return Math.sqrt(dx * dx + dy * dy) < 20;
      });
      
      // Find clicked edge
      const clickedEdge = graph.edges.find(edge => {
        const dist = pointToLineDistance(x, y, edge.from.x, edge.from.y, edge.to.x, edge.to.y);
        return dist < 10;
      });
      
      if (mode === 'add-node' && !clickedNode) {
        graph.addNode(x, y);
        drawGraph();
      } else if (mode === 'add-edge') {
        if (clickedNode) {
          if (!selectedNode) {
            selectedNode = clickedNode;
            clickedNode.color = '#ffe066';
            updateModeDisplay();
            drawGraph();
          } else if (selectedNode !== clickedNode) {
            const weight = prompt('Edge weight (default: 1):', '1');
            graph.addEdge(selectedNode, clickedNode, parseInt(weight) || 1);
            selectedNode.color = '#ddd';
            selectedNode = null;
            updateModeDisplay();
            drawGraph();
          }
        }
      } else if (mode === 'set-start' && clickedNode) {
        graph.startNode = clickedNode;
        drawGraph();
      } else if (mode === 'set-end' && clickedNode) {
        graph.endNode = clickedNode;
        drawGraph();
      } else if (mode === 'delete') {
        if (clickedNode) {
          // Remove node and connected edges
          graph.nodes = graph.nodes.filter(n => n !== clickedNode);
          graph.edges = graph.edges.filter(e => e.from !== clickedNode && e.to !== clickedNode);
          if (graph.startNode === clickedNode) graph.startNode = null;
          if (graph.endNode === clickedNode) graph.endNode = null;
          drawGraph();
        } else if (clickedEdge) {
          // Remove edge
          graph.edges = graph.edges.filter(e => e !== clickedEdge);
          drawGraph();
        }
      }
    });
    
    // Helper function for edge click detection
    function pointToLineDistance(px, py, x1, y1, x2, y2) {
      const A = px - x1;
      const B = py - y1;
      const C = x2 - x1;
      const D = y2 - y1;
      
      const dot = A * C + B * D;
      const lenSq = C * C + D * D;
      let param = -1;
      
      if (lenSq !== 0) param = dot / lenSq;
      
      let xx, yy;
      
      if (param < 0) {
        xx = x1;
        yy = y1;
      } else if (param > 1) {
        xx = x2;
        yy = y2;
      } else {
        xx = x1 + param * C;
        yy = y1 + param * D;
      }
      
      const dx = px - xx;
      const dy = py - yy;
      return Math.sqrt(dx * dx + dy * dy);
    }
    
    canvas.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      const clickedNode = graph.nodes.find(node => {
        const dx = node.x - x;
        const dy = node.y - y;
        return Math.sqrt(dx * dx + dy * dy) < 20;
      });
      
      if (clickedNode) {
        if (!graph.startNode) {
          graph.startNode = clickedNode;
        } else if (!graph.endNode && clickedNode !== graph.startNode) {
          graph.endNode = clickedNode;
        } else {
          graph.startNode = clickedNode;
          graph.endNode = null;
        }
        drawGraph();
      }
    });
    
    // Mode buttons
    function setMode(newMode) {
      mode = newMode;
      selectedNode = null;
      
      // Update active button styling
      document.querySelectorAll('.controls button').forEach(btn => {
        if (btn.id === newMode || btn.id === `${newMode}-mode`) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });
      
      updateModeDisplay();
    }
    
    document.getElementById('add-node').addEventListener('click', () => setMode('add-node'));
    document.getElementById('add-edge').addEventListener('click', () => setMode('add-edge'));
    document.getElementById('set-start').addEventListener('click', () => setMode('set-start'));
    document.getElementById('set-end').addEventListener('click', () => setMode('set-end'));
    document.getElementById('delete').addEventListener('click', () => setMode('delete'));
    
    document.getElementById('clear').addEventListener('click', () => {
      if (confirm('Clear all nodes and edges?')) {
        graph.nodes = [];
        graph.edges = [];
        graph.startNode = null;
        graph.endNode = null;
        graph.nodeIdCounter = 0;
        drawGraph();
        document.getElementById('status').textContent = 'Graph cleared';
      }
    });
    
    // Speed slider
    document.getElementById('speed').addEventListener('input', (e) => {
      speed = parseInt(e.target.value);
      document.getElementById('speed-display').textContent = speed + 'ms';
    });
    
    // Preset loading functions
    window.loadPreset = function(type) {
      graph.nodes = [];
      graph.edges = [];
      graph.startNode = null;
      graph.endNode = null;
      graph.nodeIdCounter = 0;
      
      switch(type) {
        case 'binary-tree':
          // Create binary tree
          const treeNodes = [];
          const levels = 4;
          let yOffset = 80;
          
          for (let level = 0; level < levels; level++) {
            const nodesInLevel = Math.pow(2, level);
            const xSpacing = 600 / (nodesInLevel + 1);
            
            for (let i = 0; i < nodesInLevel; i++) {
              const x = 100 + xSpacing * (i + 1);
              const y = yOffset + level * 100;
              const node = { id: graph.nodeIdCounter++, x, y, visited: false, distance: Infinity, parent: null, color: '#ddd' };
              treeNodes.push(node);
              graph.nodes.push(node);
              
              // Connect to parent
              if (level > 0) {
                const parentIndex = Math.floor((treeNodes.length - nodesInLevel - 1 + i) / 2);
                graph.edges.push({ from: treeNodes[parentIndex], to: node, weight: 1, color: '#999' });
              }
            }
          }
          break;
          
        case 'grid':
          // Create grid graph
          const rows = 5;
          const cols = 6;
          const gridNodes = [];
          
          for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
              const x = 150 + col * 100;
              const y = 100 + row * 80;
              const node = { id: graph.nodeIdCounter++, x, y, visited: false, distance: Infinity, parent: null, color: '#ddd' };
              gridNodes.push(node);
              graph.nodes.push(node);
              
              // Connect to previous node in row
              if (col > 0) {
                graph.edges.push({ from: gridNodes[gridNodes.length - 2], to: node, weight: 1, color: '#999' });
              }
              
              // Connect to node above
              if (row > 0) {
                graph.edges.push({ from: gridNodes[(row - 1) * cols + col], to: node, weight: 1, color: '#999' });
              }
            }
          }
          break;
          
        case 'complete':
          // Create complete graph (K5)
          const n = 5;
          const angleStep = (2 * Math.PI) / n;
          const radius = 150;
          const centerX = 400;
          const centerY = 250;
          const completeNodes = [];
          
          for (let i = 0; i < n; i++) {
            const angle = i * angleStep;
            const x = centerX + radius * Math.cos(angle);
            const y = centerY + radius * Math.sin(angle);
            const node = { id: graph.nodeIdCounter++, x, y, visited: false, distance: Infinity, parent: null, color: '#ddd' };
            completeNodes.push(node);
            graph.nodes.push(node);
          }
          
          // Connect all pairs
          for (let i = 0; i < n; i++) {
            for (let j = i + 1; j < n; j++) {
              graph.edges.push({ from: completeNodes[i], to: completeNodes[j], weight: Math.floor(Math.random() * 9) + 1, color: '#999' });
            }
          }
          break;
          
        case 'weighted':
          // Create weighted graph for shortest path demos
          const positions = [
            {x: 100, y: 250}, {x: 250, y: 150}, {x: 250, y: 350},
            {x: 400, y: 100}, {x: 400, y: 250}, {x: 400, y: 400},
            {x: 550, y: 150}, {x: 550, y: 350}, {x: 700, y: 250}
          ];
          
          const weightedNodes = positions.map(pos => {
            const node = { id: graph.nodeIdCounter++, x: pos.x, y: pos.y, visited: false, distance: Infinity, parent: null, color: '#ddd' };
            graph.nodes.push(node);
            return node;
          });
          
          // Create weighted edges
          const edgeData = [
            [0, 1, 4], [0, 2, 3], [1, 3, 2], [1, 4, 5],
            [2, 4, 7], [2, 5, 1], [3, 6, 3], [4, 6, 4],
            [4, 7, 2], [5, 7, 6], [6, 8, 2], [7, 8, 3]
          ];
          
          edgeData.forEach(([from, to, weight]) => {
            graph.edges.push({ from: weightedNodes[from], to: weightedNodes[to], weight, color: '#999' });
          });
          
          // Set default start and end
          graph.startNode = weightedNodes[0];
          graph.endNode = weightedNodes[8];
          break;
      }
      
      drawGraph();
      document.getElementById('status').textContent = `Loaded ${type} preset`;
    }
    
    // Algorithm functions
    async function bfs() {
      if (!graph.startNode) return;
      
      const queue = [graph.startNode];
      graph.startNode.visited = true;
      graph.startNode.distance = 0;
      let visitedCount = 0;
      
      while (queue.length > 0 && running) {
        // Handle pause
        while (paused && running) {
          await sleep(100);
        }
        if (!running) break;
        
        const current = queue.shift();
        current.color = '#51cf66';
        visitedCount++;
        document.getElementById('nodes-visited').textContent = visitedCount;
        drawGraph();
        await sleep(speed);
        
        const neighbors = graph.getNeighbors(current);
        for (const { node } of neighbors) {
          if (!node.visited) {
            node.visited = true;
            node.parent = current;
            node.distance = current.distance + 1;
            node.color = '#ffe066';
            queue.push(node);
            
            if (node === graph.endNode) {
              highlightPath();
              return;
            }
          }
        }
      }
    }
    
    async function dfs() {
      if (!graph.startNode) return;
      
      const stack = [graph.startNode];
      let visitedCount = 0;
      
      while (stack.length > 0 && running) {
        // Handle pause
        while (paused && running) {
          await sleep(100);
        }
        if (!running) break;
        
        const current = stack.pop();
        
        if (!current.visited) {
          current.visited = true;
          current.color = '#51cf66';
          visitedCount++;
          document.getElementById('nodes-visited').textContent = visitedCount;
          drawGraph();
          await sleep(speed);
          
          if (current === graph.endNode) {
            highlightPath();
            return;
          }
          
          const neighbors = graph.getNeighbors(current);
          neighbors.forEach(({ node }) => {
            if (!node.visited) {
              node.parent = current;
              node.color = '#ffe066';
              stack.push(node);
            }
          });
        }
      }
    }
    
    function highlightPath() {
      if (!graph.endNode || !graph.endNode.parent) return;
      
      let current = graph.endNode;
      let pathLength = 0;
      
      while (current.parent) {
        const parent = current.parent;
        
        // Highlight edge
        graph.edges.forEach(edge => {
          if ((edge.from === current && edge.to === parent) ||
              (edge.to === current && edge.from === parent)) {
            edge.color = '#1772d0';
          }
        });
        
        pathLength++;
        current = parent;
      }
      
      document.getElementById('path-length').textContent = pathLength;
      drawGraph();
    }
    
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    // Algorithm controls
    let paused = false;
    
    document.getElementById('run-algorithm').addEventListener('click', async () => {
      if (!graph.startNode) {
        alert('Please set a start node first!\nUse the "Set Start" button and click a node.');
        return;
      }
      
      running = true;
      paused = false;
      graph.reset();
      drawGraph();
      
      const algorithm = document.getElementById('algorithm').value;
      document.getElementById('status').textContent = 'Running ' + algorithm.toUpperCase();
      document.getElementById('nodes-visited').textContent = '0';
      document.getElementById('path-length').textContent = '-';
      
      // Set complexity
      const complexities = {
        'bfs': 'O(V + E)',
        'dfs': 'O(V + E)',
        'dijkstra': 'O((V + E) log V)',
        'astar': 'O((V + E) log V)',
        'kruskal': 'O(E log E)',
        'prim': 'O(E log V)'
      };
      document.getElementById('complexity').textContent = complexities[algorithm];
      
      // Disable edit buttons during execution
      ['add-node', 'add-edge', 'set-start', 'set-end', 'delete', 'clear'].forEach(id => {
        document.getElementById(id).disabled = true;
      });
      
      switch(algorithm) {
        case 'bfs':
          await bfs();
          break;
        case 'dfs':
          await dfs();
          break;
        // Additional algorithms can be implemented similarly
      }
      
      if (running) {
        document.getElementById('status').textContent = 'Complete';
      }
      running = false;
      
      // Re-enable edit buttons
      ['add-node', 'add-edge', 'set-start', 'set-end', 'delete', 'clear'].forEach(id => {
        document.getElementById(id).disabled = false;
      });
    });
    
    document.getElementById('pause-algorithm').addEventListener('click', () => {
      paused = !paused;
      const btn = document.getElementById('pause-algorithm');
      btn.textContent = paused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
      document.getElementById('status').textContent = paused ? 'Paused' : 'Running...';
    });
    
    document.getElementById('step-algorithm').addEventListener('click', () => {
      alert('Step-through mode coming soon!\nFor now, use Run with slower speed.');
    });
    
    document.getElementById('reset-algorithm').addEventListener('click', () => {
      running = false;
      paused = false;
      graph.reset();
      document.getElementById('status').textContent = 'Ready';
      document.getElementById('nodes-visited').textContent = '0';
      document.getElementById('path-length').textContent = '-';
      document.getElementById('pause-algorithm').textContent = '‚è∏Ô∏è Pause';
      
      // Re-enable all buttons
      ['add-node', 'add-edge', 'set-start', 'set-end', 'delete', 'clear'].forEach(id => {
        document.getElementById(id).disabled = false;
      });
      
      drawGraph();
    });
    
    document.getElementById('speed').addEventListener('input', (e) => {
      speed = 2100 - parseInt(e.target.value);
    });
    
    // Create sample graph
    function createSampleGraph() {
      const n1 = graph.addNode(200, 250);
      const n2 = graph.addNode(350, 150);
      const n3 = graph.addNode(350, 350);
      const n4 = graph.addNode(500, 250);
      const n5 = graph.addNode(650, 150);
      const n6 = graph.addNode(650, 350);
      
      graph.addEdge(n1, n2, 2);
      graph.addEdge(n1, n3, 3);
      graph.addEdge(n2, n3, 1);
      graph.addEdge(n2, n4, 4);
      graph.addEdge(n3, n4, 2);
      graph.addEdge(n4, n5, 3);
      graph.addEdge(n4, n6, 1);
      graph.addEdge(n5, n6, 2);
      
      graph.startNode = n1;
      graph.endNode = n6;
      
      drawGraph();
    }
    
    // Initialize with sample graph
    window.onload = function() {
      updateModeDisplay();
      createSampleGraph();
      
      // Show initial status
      document.getElementById('status').textContent = 'Ready - Click nodes/canvas to build graph';
    };
  </script>
</body>
</html>