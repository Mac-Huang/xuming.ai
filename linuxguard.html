<!DOCTYPE HTML>
<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LinuxGuard - Xuming Huang</title>
  <meta name="author" content="Xuming Huang">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" href="stylesheet.css">
  <link rel="icon" type="image/png" href="images/favicon.png">
  <style>
    /* Custom styles for the narrative layout */
    .narrative-section {
      margin-bottom: 60px;
    }

    .narrative-text {
      font-size: 16px;
      line-height: 1.6;
      color: #333;
    }

    .caption {
      text-align: center;
      font-size: 13px;
      color: #666;
      margin-top: 8px;
      margin-bottom: 25px;
      font-style: italic;
    }

    .image-container {
      text-align: center;
      margin: 30px 0;
    }

    .image-container img {
      max-width: 100%;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      border: 1px solid #eee;
    }

    /* Fixed height class to keep pipeline diagrams consistent */
    .fixed-height-img {
      height: 560px;
      width: auto;
      object-fit: contain;
    }

    h3 {
      margin-top: 0;
      margin-bottom: 15px;
      color: #000;
      font-weight: 700;
    }

    .highlight-box {
      background-color: #f8f9fa;
      border-left: 4px solid #444;
      padding: 15px 20px;
      margin: 20px 0;
      font-style: italic;
      color: #555;
    }

    /* Sub-headers for the solution section */
    .solution-header {
      font-size: 18px;
      font-weight: 600;
      margin-top: 30px;
      color: #1772d0;
    }

    /* Code block styles */
    .code-window {
      background: #1e1e1e;
      /* Dark background */
      border-radius: 8px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
      margin: 25px 0;
      overflow: hidden;
      border: 1px solid #333;
    }

    .code-header {
      background: #252526;
      padding: 10px 15px;
      border-bottom: 1px solid #333;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .code-title {
      color: #cccccc;
      font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
      font-size: 13px;
      font-weight: 600;
    }

    .code-content {
      max-height: 600px;
      overflow-y: auto;
      padding: 20px;
      margin: 0;
      background-color: #1e1e1e;
    }

    .code-content code {
      font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
      font-size: 13.5px;
      /* Increased size for readability */
      line-height: 1.6;
      /* Better line spacing */
      color: #e0e0e0;
      /* Brighter base text color */
      background: transparent;
      padding: 0;
      border: none;
      white-space: pre;
      display: block;
      font-weight: 500;
      /* Thicker font weight */
    }

    /* Improved Syntax Highlighting - More Vibrant Colors */
    .k {
      color: #569cd6;
      /* Keyword: Bright Blue */
      font-weight: bold;
    }

    .s {
      color: #ce9178;
      /* String: Soft Orange */
    }

    .c {
      color: #6a9955;
      /* Comment: Green */
      font-style: italic;
    }

    .f {
      color: #dcdcaa;
      /* Function: Pale Yellow */
    }

    .t {
      color: #4ec9b0;
      /* Type/Class: Teal */
    }

    .n {
      color: #9cdcfe;
      /* Variable/Property: Light Blue */
    }
  </style>
</head>

<body>
  <table
    style="width:100%;max-width:900px;border:0px;border-spacing:0px;border-collapse:separate;margin-right:auto;margin-left:auto;">
    <tbody>
      <tr style="padding:0px">
        <td style="padding:0px">

          <table
            style="width:100%;border:0px;border-spacing:0px;border-collapse:separate;margin-right:auto;margin-left:auto;">
            <tbody>
              <tr>
                <td style="padding:20px;width:100%;vertical-align:middle">
                  <p style="text-align:center">
                    <name>LinuxGuard</name>
                  </p>
                  <p style="text-align:center;color:#666;margin-top:5px;">
                    Turning Commit History into Security Checkers via LLMs
                  </p>
                  <p style="text-align:center;font-size:16px;">
                    <a href="index.html">Home</a> &nbsp;/&nbsp;
                    <a href="research.html">Research</a> &nbsp;/&nbsp;
                    <a href="blog/posts/linuxguard-journey.html">Read the Retrospective Blog</a>
                  </p>
                </td>
              </tr>
            </tbody>
          </table>

          <div class="highlight-box">
            <strong>Status Update:</strong> We concluded development in November 2025 following the publication
            of <em>KNighter</em> (SOSP '24), which validated a similar approach. <a
              href="blog/posts/linuxguard-journey.html">Read
              my full retrospective here.</a>
          </div>

          <table
            style="width:100%;border:0px;border-spacing:0px;border-collapse:separate;margin-right:auto;margin-left:auto;">
            <tbody>
              <tr>
                <td style="padding:20px;width:100%;vertical-align:middle">

                  <div class="narrative-section">
                    <heading>The Vision</heading>
                    <p class="narrative-text">
                      The Linux kernel is a massive, living codebase. Every day, developers fix bugs, but often these
                      bugs follow repetitive "anti-patterns"‚Äîmissing locks, incorrect error handling, or uninitialized
                      variables.
                      <strong>LinuxGuard</strong> began with a simple question: <em>Can we teach an AI to read a bug-fix
                        commit and write a static analysis tool to prevent that bug forever?</em>
                    </p>
                    <div class="image-container">
                      <img src="images/papers/linuxguard_paradigm.jpg" alt="LinuxGuard Paradigm">
                      <div class="caption">Figure 1: The Vision. Utilizing LLMs to bridge the gap between unstructured
                        commit messages and structured AST Matchers.</div>
                    </div>
                  </div>

                  <hr>

                  <div class="narrative-section">
                    <heading>Phase 1: The Hurdle</heading>
                    <p class="narrative-text">
                      Our initial attempt was straightforward (the "Naive Pipeline"). We fed the diff and commit message
                      directly into an LLM (like GPT-4) and asked it to "write a Clang AST Matcher."
                    </p>
                    <div class="image-container">
                      <img class="fixed-height-img" src="images/papers/Prototype-Pipeline.jpg" alt="Prototype Pipeline">
                      <div class="caption">Figure 2: The Naive Pipeline. A simple single-pass prompt that often led to
                        compilation errors.</div>
                    </div>
                    <p class="narrative-text">
                      <strong>The Result? Failure.</strong> The generated C++ code rarely compiled. The LLM would
                      hallucinate Clang APIs that didn't exist or write matchers that were syntactically correct but
                      semantically meaningless. We realized that a single inference step was insufficient for the
                      complexity of the Clang AST.
                    </p>
                  </div>

                  <div class="narrative-section" style="background-color: #f9f9f9; padding: 20px; border-radius: 8px;">
                    <heading>The Pivot: Strategic Evolution</heading>
                    <p class="narrative-text">
                      Faced with these failures, we had to rethink our approach. We analyzed <em>why</em> the model was
                      failing and realized there was a <strong>reasoning gap</strong>. A human developer doesn't just
                      "output code"; they analyze the bug, formulate a logic, and then iteratively refine their code.
                    </p>
                    <p class="narrative-text">
                      We decided to restructure the pipeline to mimic this cognitive process. The diagram below
                      illustrates our thought process: moving from "direct generation" to a layered approach that
                      integrates <strong>reasoning (Chain-of-Thought)</strong> and <strong>feedback
                        (Self-Correction)</strong>.
                    </p>
                    <div class="image-container">
                      <img class="fixed-height-img" img src="images/papers/TraceBack.jpg"
                        alt="Strategic Evolution Process">
                      <div class="caption">Figure 3: Strategic Evolution. Our reasoning process for evolving the
                        pipeline from simple prompting to a robust, multi-agent system.</div>
                    </div>
                  </div>

                  <div class="narrative-section">
                    <heading>The Solution: An Intelligent Pipeline</heading>
                    <p class="narrative-text">
                      Guided by the strategy above, we implemented two key architectural improvements that transformed
                      LinuxGuard into a working tool.
                    </p>

                    <div class="solution-header">1. Chain-of-Thought Synthesis</div>
                    <p class="narrative-text">
                      We decoupled analysis from generation. We forced the model to "think" before it coded: first,
                      explain <em>why</em> the code is buggy; second, describe the pattern in plain English; and only
                      then, generate the C++ matcher code.
                    </p>
                    <div class="image-container">
                      <img class="fixed-height-img" src="images/papers/EnhancedPipeline.jpg"
                        alt="Enhanced Pipeline with CoT">
                      <div class="caption">Figure 4: Chain-of-Thought. By explicitly separating reasoning from coding,
                        we significantly improved semantic accuracy.</div>
                    </div>

                    <div class="solution-header">2. The Self-Healing Loop</div>
                    <p class="narrative-text">
                      To handle syntax errors, we introduced a <strong>Repair Agent</strong>. When the Clang compiler
                      throws an error, we capture the `stderr` output and feed it back to the LLM, creating a
                      closed-loop system that iterates until the checker compiles successfully.
                    </p>
                    <div class="image-container">
                      <img class="fixed-height-img" src="images/papers/repair-overview.jpg" alt="Repair Loop">
                      <div class="caption">Figure 5: Self-Healing. The system automatically fixes compilation errors
                        without human intervention.</div>
                    </div>
                  </div>

                  <div class="narrative-section">
                    <heading>System Integration</heading>
                    <p class="narrative-text">
                      Finally, the generated checkers were not just theoretical. We built a harness that injects these
                      dynamically generated matchers into the standard Linux kernel build process as full
                      <code>clang-tidy</code> plugins, enabling us to scan historical kernel versions.
                    </p>
                    <div class="image-container">
                      <img src="images/papers/linuxguard_LLVM_struct.jpg" alt="LLVM Structure">
                      <div class="caption">Figure 6: Real-world Integration. Embedding our AI-generated tools into the
                        LLVM/Clang ecosystem.</div>
                    </div>
                  </div>

                  <div class="narrative-section">
                    <heading>The Engine: Pipeline Orchestrator</heading>
                    <p class="narrative-text">
                      At the heart of LinuxGuard lies the <strong>Orchestrator</strong>, a Python-based engine that
                      manages the entire lifecycle of a checker. The excerpt below highlights the core
                      <code>generate_checker</code> loop, which drives the Chain-of-Thought generation and manages the
                      self-healing compilation process.
                    </p>

                    <div class="code-window">
                      <div class="code-header">
                        <span class="code-title">pipeline_orchestrator.py (Core Logic Excerpt)</span>
                      </div>
                      <pre class="code-content"><code><span class="k">class</span> <span class="t">PipelineOrchestrator</span>:
    <span class="c">"""Orchestrates the complete pipeline with iterative generation and repair."""</span>

    <span class="k">def</span> <span class="f">generate_checker</span>(<span class="s">self</span>, <span class="n">commit_hash</span>: <span class="t">str</span>) -> <span class="t">Optional</span>[<span class="t">Dict</span>]:
        <span class="c"># ... [Initial setup and context loading omitted] ...</span>

        <span class="k">for</span> <span class="n">iteration</span> <span class="k">in</span> <span class="f">range</span>(1, <span class="s">self</span>.<span class="n">max_iterations</span> + 1):
            <span class="f">print</span>(<span class="s">f"‚îÅ‚îÅ‚îÅ Iteration {iteration}/{self.max_iterations} ‚îÅ‚îÅ‚îÅ"</span>)

            <span class="c"># Stage 1: Multi-commit Pattern Extraction</span>
            <span class="c"># We aggregate insights from multiple similar commits to avoid overfitting</span>
            <span class="n">candidate_commits</span> = <span class="s">self</span>.<span class="f">collect_candidate_commits</span>(<span class="n">commit_hash</span>)
            <span class="n">analysis_result</span> = <span class="s">self</span>.<span class="f">analyze_commits</span>(<span class="n">candidate_commits</span>)
            
            <span class="k">if not</span> <span class="n">analysis_result</span>:
                <span class="k">continue</span>

            <span class="n">pattern</span>, <span class="n">guidance</span> = <span class="n">analysis_result</span>
            
            <span class="c"># Stage 2 & 3: Synthesis & Implementation (Chain-of-Thought)</span>
            <span class="c"># The model first plans the logic (Module 1) then writes the C++ (Module 2)</span>
            <span class="n">checker_info</span> = <span class="s">self</span>.<span class="f">implement_checker</span>(<span class="n">pattern</span>, <span class="n">guidance</span>)

            <span class="c"># Stage 4: Build & Repair Loop (Self-Healing)</span>
            <span class="n">build_success</span> = <span class="k">False</span>
            <span class="k">for</span> <span class="n">attempt</span> <span class="k">in</span> <span class="f">range</span>(1, <span class="s">self</span>.<span class="n">max_repair_attempts</span> + 1):
                
                <span class="c"># Try to compile the generated Clang plugin</span>
                <span class="n">build_success</span>, <span class="n">errors</span> = <span class="s">self</span>.<span class="f">build_checker</span>(<span class="n">checker_info</span>)

                <span class="k">if</span> <span class="n">build_success</span>:
                    <span class="k">break</span> 

                <span class="c"># If build fails, feed stderr back to the LLM for repair</span>
                <span class="f">print</span>(<span class="s">f"üîß Attempting repair ({attempt}/{self.max_repair_attempts})..."</span>)
                <span class="n">repaired</span> = <span class="s">self</span>.<span class="f">repair_checker</span>(<span class="n">checker_info</span>, <span class="n">errors</span>, <span class="n">pattern</span>)
                
                <span class="k">if not</span> <span class="n">repaired</span>:
                    <span class="k">break</span>

            <span class="k">if not</span> <span class="n">build_success</span>:
                <span class="k">continue</span> <span class="c"># Retry with a fresh generation if repair fails</span>

            <span class="c"># Stage 5: Validation</span>
            <span class="c"># Run the compiled checker on historical kernels to verify findings</span>
            <span class="n">is_valid</span> = <span class="s">self</span>.<span class="f">validate_checker</span>(<span class="n">checker_info</span>, <span class="n">commit_hash</span>)

            <span class="k">if</span> <span class="n">is_valid</span>:
                <span class="f">print</span>(<span class="s">"‚úì SUCCESS: Valid checker generated!"</span>)
                <span class="k">return</span> <span class="n">checker_info</span>

        <span class="k">return</span> <span class="k">None</span>

    <span class="k">def</span> <span class="f">repair_checker</span>(<span class="s">self</span>, <span class="n">checker_info</span>: <span class="t">Dict</span>, <span class="n">errors</span>: <span class="t">str</span>, <span class="n">pattern</span>: <span class="t">Dict</span>) -> <span class="t">bool</span>:
        <span class="c">"""Use LLM to repair compilation errors by analyzing clang diagnostic output."""</span>
        
        <span class="c"># Load current (broken) source code</span>
        <span class="n">h_code</span>, <span class="n">cpp_code</span> = <span class="s">self</span>.<span class="f">load_checker_source</span>(<span class="n">checker_info</span>)

        <span class="c"># Create repair prompt with the specific compiler errors</span>
        <span class="n">prompt</span> = <span class="f">build_repair_prompt</span>(
            <span class="n">code</span>=(<span class="n">h_code</span>, <span class="n">cpp_code</span>),
            <span class="n">compiler_errors</span>=<span class="n">errors</span>,
            <span class="n">context</span>=<span class="n">pattern</span>
        )

        <span class="c"># Ask LLM to fix the syntax/API issues</span>
        <span class="n">response</span> = <span class="s">self</span>.<span class="n">repair_model</span>.<span class="f">generate_content</span>(<span class="n">prompt</span>)
        
        <span class="c"># ... [Code extraction and file saving omitted] ...</span>

        <span class="k">return</span> <span class="k">True</span></code></pre>
                    </div>
                  </div>

                  <heading>Resources</heading>
                  <ul>
                    <li><a href="https://github.com/Mac-Huang/LinuxGuard"><strong>GitHub Repository</strong></a>: Source
                      code for the pipeline and LLVM integration.</li>
                    <li><a
                        href="https://docs.google.com/presentation/d/1C7oh9bZH-TeVXoMrKA4UIXCeDggZuWJuFwzy2lfoKWE/edit?usp=sharing"><strong>Weekly
                          Research Logs</strong></a>: A slide deck documenting our experiments and progress.</li>
                  </ul>

                </td>
              </tr>
            </tbody>
          </table>

          <table
            style="width:100%;border:0px;border-spacing:0px;border-collapse:separate;margin-right:auto;margin-left:auto;">
            <tbody>
              <tr>
                <td style="padding:0px">
                  <br>
                  <p style="text-align:center;font-size:14px;color:#999;padding:20px;">
                    &copy; 2025 Xuming Huang.
                  </p>
                </td>
              </tr>
            </tbody>
          </table>

        </td>
      </tr>
    </tbody>
  </table>
</body>

</html>